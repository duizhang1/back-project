/*
 Navicat Premium Data Transfer

 Source Server         : java
 Source Server Type    : MySQL
 Source Server Version : 80022
 Source Host           : localhost:3306
 Source Schema         : notnull

 Target Server Type    : MySQL
 Target Server Version : 80022
 File Encoding         : 65001

 Date: 01/03/2023 22:09:28
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for wf_article
-- ----------------------------
DROP TABLE IF EXISTS `wf_article`;
CREATE TABLE `wf_article`  (
  `uuid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT 'uuid主键',
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章标题',
  `img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章封面链接',
  `summary` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章摘要',
  `content` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '文章内容',
  `creator_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '创建者id',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建日期',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `sort_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '分类id',
  `read_count` int NULL DEFAULT NULL COMMENT '阅读数',
  `like_count` int NULL DEFAULT NULL COMMENT '点赞数',
  `store_count` int NULL DEFAULT NULL COMMENT '收藏数',
  `title_state` int NULL DEFAULT NULL COMMENT '文章状态：1审核中，2已发布，3未通过',
  `score` int NULL DEFAULT NULL COMMENT '文章评分',
  PRIMARY KEY (`uuid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of wf_article
-- ----------------------------
INSERT INTO `wf_article` VALUES ('2197f77c59b7cc80a5f9e73d1f7074c9', 'Redis在centos7下安装Redis在centos7下安装', NULL, 'Redis在centos7下安装Redis在centos7下安装Redis在centos7下安装', '                \nRedis版本6.2.5\n\n如果可以的话可以自行查看[官方下载](https://redis.io/download)\n\n## 下载安装包，编译安装\n\n```bash\n下载的地址就是下载右击后复制的地址,wget所在的地址就是压缩包所在的地址，依次执行以下指令\n$ wget https://download.redis.io/releases/redis-6.2.5.tar.gz\n$ tar xzf redis-6.2.5.tar.gz\n$ cd redis-6.2.5\n$ make\n```\n\n若出现make出错，原因可能是gcc-c++没有安装，执行以下进行安装\n\n```bash\n$ yum install gcc-c++\n```\n\n\n\n## 修改redis.conf\n\n为了能让Redis能够后台启动，修改在当前目录下的redis.conf\n\n```bash\n$ vim redis.conf\n```\n\n![Redissetup1](https://gitee.com/captain-66/picpath/raw/master/mdimg/Redissetup1.png)\n\n\n\n## 启动Redis\n\n```bash\n继续执行以下指令,就是到src目录下执行redis-server启动.\n后面的参数就是指定执行我们刚刚在redis目录下修改的conf文件，若不指定，他就会执行默认的conf\n$ src/redis-server redis.conf\n```\n\n不报任何消息表示打开完成，进行下一步。如果出现了一个很大的数据库的图形，表示前台开启，没有修改上一步的参数。为什么不前台开启，因为如果前台开启，就不能执行其他命令，而且该前台不能关闭，所以执行后台开启。\n\n\n\n## 测试Redis\n\n```bash\n$ src/redis-cli -p 6379\n127.0.0.1:6379>ping\nPONG                   <-此处出现PONG即成功\n\n使用set和get来实验一下\n\n127.0.0.1:6379>set name duizhang\nOK\n127.0.0.1:6379>get name\n\"duizhang\"\n\n成功执行了\n\n127.0.0.1:6379>shutdown        <-关闭redis服务\nnot connected>exit             <-离开\n```\n\n行云流水下来，没有报错啥的，基本就可以了。', 'a1c2c1150add8182cb2c4389cfdae0df', '2023-01-18 02:22:42', '2023-02-25 23:30:00', '2', 448, 1, 0, 1, NULL);
INSERT INTO `wf_article` VALUES ('4aa5086163e5c22a32873a0f7a4376db', 'JUC自定义线程池练习', 'http://resource.duizhangz.cn//FqhrHawMGXoRRBWx-NKMp4wqfOT4', 'JUC自定义线程池练习JUC自定义线程池练习JUC自定义线程池练习JUC自定义线程池练习JUC自定义线程池练习', '## JUC自定义线程池练习\r\n\r\n![自定义线程池执行流程](JUC线程池练习.assets/自定义线程池执行流程.png)\r\n\r\n首先上面该线程池的大致流程\r\n\r\n### 自定义阻塞队列\r\n\r\n* 首先定义一个双向的队列和锁一定两个等待的condition\r\n* 本类用lock来控制多线程下的流程执行\r\n* take和push方法就是死等，调用await就是等，后面优化为限时等待\r\n* take调用后取出阻塞队列的task后会调用fullWaitSet的signal方法来唤醒因为阻塞队列满了的线程将task放入阻塞队列。\r\n\r\n```Java\r\n@Slf4j\r\nclass TaskQueue<T> {\r\n\r\n    // 双向的阻塞队列\r\n    private Deque<T> deque;\r\n    // 队列最大容量\r\n    private int capacity;\r\n\r\n    // 锁\r\n    private ReentrantLock lock = new ReentrantLock();\r\n    // 消费者任务池空的等待队列\r\n    private Condition emptyWaitSet = lock.newCondition();\r\n    // 生产者任务池满的等待队列\r\n    private Condition fullWaitSet = lock.newCondition();\r\n\r\n\r\n    public TaskQueue(int capacity) {\r\n        this.capacity = capacity;\r\n        deque = new ArrayDeque<>(capacity);\r\n    }\r\n\r\n    // 死等take，即从阻塞队列取出任务\r\n    public T take() {\r\n        lock.lock();\r\n        try {\r\n            while (deque.isEmpty()) {\r\n                try {\r\n                    emptyWaitSet.await();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            log.debug(\"取走任务\");\r\n            T task = deque.pollFirst();\r\n            fullWaitSet.signal();\r\n            return task;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    // 线程添加任务，属于是死等添加\r\n    public void push(T task) {\r\n        lock.lock();\r\n        try {\r\n            while (deque.size() >= capacity) {\r\n                try {\r\n                    fullWaitSet.await();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            log.debug(\"添加任务\");\r\n            deque.offerLast(task);\r\n            emptyWaitSet.signal();\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public int getSize() {\r\n        lock.lock();\r\n        try {\r\n            return deque.size();\r\n        }finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 优化，死等优化为超时等\r\n\r\n* awaitNanos方法返回的是等待的剩余时间，如果已经等了base时间就会返回0，如果没有就会返回大于0即还没有等待的时间，防止虚假唤醒导致重新等待时间加长。当然在本题的设计中不会出现虚假唤醒的情况。\r\n\r\n```Java\r\npublic T poll(Long timeout,TimeUnit unit) {\r\n    lock.lock();\r\n    try {\r\n        long base = unit.toNanos(timeout);\r\n        while (deque.isEmpty()) {\r\n            try {\r\n                if (base <= 0){\r\n                    return null;\r\n                }\r\n                base = emptyWaitSet.awaitNanos(base);  // 返回还剩下的时间\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        log.debug(\"取走任务\");\r\n        T task = deque.pollFirst();\r\n        fullWaitSet.signal();\r\n        return task;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}\r\n```\r\n\r\n### 线程池类\r\n\r\n* 成员变量如下，对于Worker就工作线程\r\n\r\n```Java\r\n@Slf4j\r\nclass ThreadPool {\r\n    // 阻塞队列大小\r\n    private int capacity;\r\n    // 阻塞队列\r\n    private TaskQueue<Runnable> taskQueue;\r\n    // 工作线程\r\n    private HashSet<Worker> workerSet = new HashSet<>();\r\n    // 核心数\r\n    private int coreNum;\r\n    // 超时等待时间\r\n    private long timeout;\r\n    // 超时等待单位\r\n    private TimeUnit unit;\r\n    // 拒绝策略\r\n    private RejectPolicy rejectPolicy;\r\n\r\n    // 线程对象\r\n    class Worker extends Thread {\r\n\r\n        private Runnable task;\r\n\r\n        public Worker(Runnable runnable) {\r\n            this.task = runnable;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            // 就是线程把当前分配的任务做完，然后还要去阻塞队列找活干，没活就退出\r\n            // taks 如果不为空就执行然后讲其置为空，后续再次进入循环后会从阻塞队列中再次取出task，\r\n            // 如果不为空就继续执行，但是因为take死等，会导致无法结束\r\n            // 使用了这个超时等的方法，当无法取出时就会退出程序\r\n            while (task != null || (task = taskQueue.poll(timeout,unit)) != null) {\r\n                try {\r\n                    log.debug(\"开始执行任务\");\r\n                    Thread.sleep(1000);\r\n                    task.run();\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                } finally {\r\n                    task = null;\r\n                }\r\n            }\r\n            // 当没有任务可执行，线程自动销毁，由于这是根据对象来销毁，且hashset无序，所以这里无需保证其的线程安全。\r\n            workerSet.remove(this);\r\n        }\r\n    }\r\n\r\n\r\n    public ThreadPool(int capacity, int coreNum, long timeout, TimeUnit unit,RejectPolicy rejectPolicy) {\r\n        this.capacity = capacity;\r\n        this.coreNum = coreNum;\r\n        this.timeout = timeout;\r\n        this.unit = unit;\r\n        this.taskQueue = new TaskQueue<>(capacity);\r\n        this.rejectPolicy = rejectPolicy;\r\n    }\r\n\r\n    /**\r\n     * 当线程数大于核心数，就将任务放入阻塞队列\r\n     * 否则创建线程进行处理\r\n     *\r\n     * @param runnable\r\n     */\r\n    public void execute(Runnable runnable) {\r\n        // 需要synchronized关键字控制多线程下对执行方法的执行，保证共享变量workerSet安全。\r\n        synchronized (workerSet) {\r\n            // 如果已经存在的工作线程已经大于核心数，就不适合在进行创建线程了，创太多线程对于执行并不会加快，反而会因为线程不断切换而拖累CPU的执行。\r\n            if (workerSet.size() >= coreNum) {\r\n                taskQueue.push(runnable);\r\n            } else {\r\n                // 如果工作线程小于核心数就可创建一个worker线程来工作\r\n                Worker worker = new Worker(runnable);\r\n                workerSet.add(worker);\r\n                worker.start();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 测试类\r\n\r\n```Java\r\n@Slf4j\r\npublic class MyThreadPool {\r\n\r\n    public static void main(String[] args) {\r\n        ThreadPool threadPool = new ThreadPool(3,2,1,TimeUnit.SECONDS,(taskQueue,task)->{\r\n            taskQueue.push(task);\r\n        });\r\n        for (int i = 0; i < 10; i++) {\r\n            int j = i;\r\n            threadPool.execute(() -> {\r\n                log.debug(\"任务{}\", j);\r\n            });\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 优化---拒绝策略\r\n\r\n我们没有进行优化的就是当任务太多导致阻塞线程也满了，此时任务线程就会进行阻塞，直到等到有人在线程池中取走任务。也就是push方法，我们在旧的方法中仍采用的是死等的方法。\r\n\r\n但是方法中有很多死等，超时等，放弃任务，抛出异常，让调用者自己执行任务等等方法。\r\n\r\n我们就可用讲其进行抽象，把操作交给调用者。\r\n\r\n定义了如下的函数式接口，即为拒绝策略。\r\n\r\n```Java\r\n@FunctionalInterface\r\ninterface RejectPolicy<T>{\r\n    void reject(TaskQueue<T> taskQueue,T task);\r\n}\r\n```\r\n\r\n将在TaskQueue任务队列中定义不同的策略，我们只要传入这个函数式接口的实现对象就可用实现定制拒绝的策略。\r\n\r\n在TaskQueue类添加一个方法，用来调用拒绝策略\r\n\r\n```Java\r\npublic void tryAndAdd(T task,RejectPolicy rejectPolicy){\r\n    lock.lock();\r\n    try {\r\n        if (deque.size() >= capacity) {\r\n            rejectPolicy.reject(this,task);\r\n        }else{\r\n            log.debug(\"添加任务\");\r\n            deque.offerLast(task);\r\n            emptyWaitSet.signal();\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}\r\n```\r\n\r\n更改了构造方法的线程池类，这样就可用传入一个自定义的拒绝策略。\r\n\r\n```Java\r\n@Slf4j\r\nclass ThreadPool {\r\n    // 阻塞队列大小\r\n    private int capacity;\r\n    // 阻塞队列\r\n    private TaskQueue<Runnable> taskQueue;\r\n    // 工作线程\r\n    private HashSet<Worker> workerSet = new HashSet<>();\r\n    // 核心数\r\n    private int coreNum;\r\n    // 超时等待时间\r\n    private long timeout;\r\n    // 超时等待单位\r\n    private TimeUnit unit;\r\n    // 拒绝策略\r\n    private RejectPolicy rejectPolicy;\r\n\r\n    // 线程对象\r\n    class Worker extends Thread {\r\n\r\n        private Runnable task;\r\n\r\n        public Worker(Runnable runnable) {\r\n            this.task = runnable;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            while (task != null || (task = taskQueue.poll(timeout,unit)) != null) {\r\n                try {\r\n                    log.debug(\"开始执行任务\");\r\n                    Thread.sleep(1000);\r\n                    task.run();\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                } finally {\r\n                    task = null;\r\n                }\r\n            }\r\n            workerSet.remove(this);\r\n        }\r\n    }\r\n\r\n\r\n    public ThreadPool(int capacity, int coreNum, long timeout, TimeUnit unit,RejectPolicy rejectPolicy) {\r\n        this.capacity = capacity;\r\n        this.coreNum = coreNum;\r\n        this.timeout = timeout;\r\n        this.unit = unit;\r\n        this.taskQueue = new TaskQueue<>(capacity);\r\n        this.rejectPolicy = rejectPolicy;\r\n    }\r\n\r\n    /**\r\n     * 当线程数大于核心数，就将任务放入阻塞队列\r\n     * 否则创建线程进行处理\r\n     *\r\n     * @param runnable\r\n     */\r\n    public void execute(Runnable runnable) {\r\n        synchronized (workerSet) {\r\n            if (workerSet.size() >= coreNum) {\r\n                taskQueue.tryAndAdd(runnable,rejectPolicy);\r\n            } else {\r\n                Worker worker = new Worker(runnable);\r\n                workerSet.add(worker);\r\n                worker.start();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n将启动类修改如下\r\n\r\n```Java\r\n@Slf4j\r\npublic class MyThreadPool {\r\n\r\n    public static void main(String[] args) {\r\n        ThreadPool threadPool = new ThreadPool(3,2,1,TimeUnit.SECONDS,(taskQueue,task)->{\r\n            // 采用死等的方法，当然我们可用在taskQueue中定义更多的方法让调用者选择\r\n            taskQueue.push(task);\r\n        });\r\n        for (int i = 0; i < 10; i++) {\r\n            int j = i;\r\n            threadPool.execute(() -> {\r\n                log.debug(\"任务{}\", j);\r\n            });\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n这样我们就完成了自定义的线程池。', 'a1c2c1150add8182cb2c4389cfdae0df', '2023-01-27 19:33:07', '2023-02-03 03:00:00', '2', 8, 0, 0, 1, NULL);
INSERT INTO `wf_article` VALUES ('4d21245c1b9e45143d7d9f7892ae0f91', '阿里云centos7安装RabbitMQ', NULL, '阿里云centos7安装RabbitMQ', '# 阿里云centos7安装RabbitMQ\r\n\r\n## 在rabbitMQ官网查看版本对应的erlang版本依赖\r\n\r\nhttps://www.rabbitmq.com/which-erlang.html\r\n\r\n进入即可\r\n\r\n## 去下面两个网站下载对应的rpm包\r\n\r\nhttps://github.com/rabbitmq/rabbitmq-server/releases?after=v3.8.6-rc.1\r\n\r\nhttps://github.com/rabbitmq/erlang-rpm/releases?after=v23.0.4\r\n\r\n\r\n\r\n用XFTP直接将两个rpm包传到centos7服务器中\r\n\r\n```shell\r\n第一步，到对应目录下yum安装\r\nyum -y install erlang-23.0.2-1.el7.x86_64.rpm\r\nyum -y install rabbitmq-server-3.8.5-1.el7.noarch.rpm\r\n```\r\n\r\n安装完后\r\n\r\n```shell\r\n1.输入以下命令打开插件列表，启用使用页面管理\r\nrabbitmq-plugins list\r\n\r\n2.可以看到rabbitmq_management，输入以下命令\r\nrabbitmq-plugins enable rabbitmq_management\r\n```\r\n\r\n启动rabbitMQ\r\n\r\n```shell\r\nsystemctl start rabbitmq-server.service\r\n\r\n查看启动状态，active启动成功\r\nsystemctl status rabbitmq-server.service\r\n```\r\n\r\n在去阿里云安全组打开15672端口\r\n\r\n在本地用IP:15672打开对应页面，说明启用插件成功\r\n\r\n\r\n\r\n用户名guest密码guest\r\n\r\n>  无法远程登陆，执行以下命令\r\n>\r\n> cd /etc/rabbitmq/\r\n>\r\n> vim rabbitmq.config\r\n>\r\n> 以下内容输入后，保存退出\r\n>\r\n> ```shell \r\n> [{rabbit,[{loopback_users,[]}]}].\r\n> ```\r\n>\r\n> 重启rabbitMQ服务\r\n>\r\n> systemctl restart rabbitmq-server.service\r\n\r\n', 'a1c2c1150add8182cb2c4389cfdae0df', '2023-01-15 13:34:06', NULL, '2', 0, 0, 0, 1, NULL);
INSERT INTO `wf_article` VALUES ('8aa1bf522eec29c1eb2b718c2fc247c5', 'vue创建', 'http://roeuo9svc.hn-bkt.clouddn.com/HTaprcuVLSNS1HOE2F2xI', 'vue创建,创建Vue在webpack工程1.创建webpack项目2.安装依赖vue创建,创建Vue在webpack工程1.创建webpack项目2.安装依赖', '## 创建Vue在webpack工程\r\n\r\n### 1.创建webpack项目\r\n\r\n```xml\r\nvue init webpack [项目名]\r\n\r\n#遇到的选项直接回车跳过或者NO，都选择自己创建,可能要等很久\r\n#vuebuild选择运行时编译第一个\r\n#太慢可以先cnpm install webpack在执行\r\n```\r\n\r\n\r\n\r\n### 2.安装依赖\r\n\r\n```xml\r\n打包到生产环境的话还是建议使用CDN引入，后面会将一些常见的CDN引用\r\n\r\n#进入工程目录\r\ncd [项目名]\r\n\r\n#安装依赖???  安装中出现WARN deprecated是正常的\r\n#如果出现错误他会告诉你输入什么命令去修复\r\nnpm install\r\n\r\n#安装vue-router\r\nnpm install vue-router --save-dev\r\n\r\n#安装elementui，如果需要的话\r\nnpm i element-ui -S\r\n\r\n\r\n#安装sass加载器，也可以安装less\r\nnpm install sass-loader node-sass --save-dev\r\n\r\n#还有axios用来请求后端数据，即封装好的Ajax\r\nnpm install axios\r\n\r\n#启动测试\r\nnpm run dev\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 3.首先在main.js中导入入口文件\r\n\r\n```xml\r\n#导入了elementui的文件\r\nimport Element from \'element-ui\';\r\nimport \'element-ui/lib/theme-chalk/index.css\';\r\n\r\nVue.use(Element);\r\n在Vue实例中加入render: h => h(App)\r\n\r\n\r\n\r\n#导入了router的文件,需要在main.js同级目录下创建router文件夹和index.js\r\nimport router from \'./router\'\r\n\r\n在Vue实例中加入router\r\n\r\n#导入了axios的文件\r\nimport axios from \'axios\'\r\n\r\nVue.prototype.$http=axios;\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 4.创建router目录下的index文件\r\n\r\n```xml\r\nimport Vue from \"vue\";\r\nimport Router from \"vue-router\";\r\n\r\nVue.use(Router);\r\n\r\nexport default new Router({\r\n  routes:[\r\n    {\r\n      path: \'/\',\r\n      component: Main,\r\n      children: [\r\n        {path:\'/main/:id\',component:text}\r\n      ]\r\n    }\r\n  ]\r\n})\r\n\r\n```\r\n\r\n\r\n\r\n到此为止，vue项目的初始化就完成了，有vue-cli我不会，我是后端路线的程序猿，所以简单可以开发就差不多了。\r\n\r\n### \r\n\r\n\r\n\r\n', 'a1c2c1150add8182cb2c4389cfdae0df', '2023-01-15 13:48:31', '2023-02-02 02:00:00', '1', 2, 0, 0, 1, NULL);
INSERT INTO `wf_article` VALUES ('8de746f565f6ad0362fc0365db17ccc7', 'JUC自定义线程池练习', 'http://resource.duizhangz.cn//FqhrHawMGXoRRBWx-NKMp4wqfOT4', 'JUC自定义线程池练习JUC自定义线程池练习JUC自定义线程池练习JUC自定义线程池练习JUC自定义线程池练习', '## JUC自定义线程池练习\r\n\r\n![自定义线程池执行流程](JUC线程池练习.assets/自定义线程池执行流程.png)\r\n\r\n首先上面该线程池的大致流程\r\n\r\n### 自定义阻塞队列\r\n\r\n* 首先定义一个双向的队列和锁一定两个等待的condition\r\n* 本类用lock来控制多线程下的流程执行\r\n* take和push方法就是死等，调用await就是等，后面优化为限时等待\r\n* take调用后取出阻塞队列的task后会调用fullWaitSet的signal方法来唤醒因为阻塞队列满了的线程将task放入阻塞队列。\r\n\r\n```Java\r\n@Slf4j\r\nclass TaskQueue<T> {\r\n\r\n    // 双向的阻塞队列\r\n    private Deque<T> deque;\r\n    // 队列最大容量\r\n    private int capacity;\r\n\r\n    // 锁\r\n    private ReentrantLock lock = new ReentrantLock();\r\n    // 消费者任务池空的等待队列\r\n    private Condition emptyWaitSet = lock.newCondition();\r\n    // 生产者任务池满的等待队列\r\n    private Condition fullWaitSet = lock.newCondition();\r\n\r\n\r\n    public TaskQueue(int capacity) {\r\n        this.capacity = capacity;\r\n        deque = new ArrayDeque<>(capacity);\r\n    }\r\n\r\n    // 死等take，即从阻塞队列取出任务\r\n    public T take() {\r\n        lock.lock();\r\n        try {\r\n            while (deque.isEmpty()) {\r\n                try {\r\n                    emptyWaitSet.await();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            log.debug(\"取走任务\");\r\n            T task = deque.pollFirst();\r\n            fullWaitSet.signal();\r\n            return task;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    // 线程添加任务，属于是死等添加\r\n    public void push(T task) {\r\n        lock.lock();\r\n        try {\r\n            while (deque.size() >= capacity) {\r\n                try {\r\n                    fullWaitSet.await();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            log.debug(\"添加任务\");\r\n            deque.offerLast(task);\r\n            emptyWaitSet.signal();\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public int getSize() {\r\n        lock.lock();\r\n        try {\r\n            return deque.size();\r\n        }finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 优化，死等优化为超时等\r\n\r\n* awaitNanos方法返回的是等待的剩余时间，如果已经等了base时间就会返回0，如果没有就会返回大于0即还没有等待的时间，防止虚假唤醒导致重新等待时间加长。当然在本题的设计中不会出现虚假唤醒的情况。\r\n\r\n```Java\r\npublic T poll(Long timeout,TimeUnit unit) {\r\n    lock.lock();\r\n    try {\r\n        long base = unit.toNanos(timeout);\r\n        while (deque.isEmpty()) {\r\n            try {\r\n                if (base <= 0){\r\n                    return null;\r\n                }\r\n                base = emptyWaitSet.awaitNanos(base);  // 返回还剩下的时间\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        log.debug(\"取走任务\");\r\n        T task = deque.pollFirst();\r\n        fullWaitSet.signal();\r\n        return task;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}\r\n```\r\n\r\n### 线程池类\r\n\r\n* 成员变量如下，对于Worker就工作线程\r\n\r\n```Java\r\n@Slf4j\r\nclass ThreadPool {\r\n    // 阻塞队列大小\r\n    private int capacity;\r\n    // 阻塞队列\r\n    private TaskQueue<Runnable> taskQueue;\r\n    // 工作线程\r\n    private HashSet<Worker> workerSet = new HashSet<>();\r\n    // 核心数\r\n    private int coreNum;\r\n    // 超时等待时间\r\n    private long timeout;\r\n    // 超时等待单位\r\n    private TimeUnit unit;\r\n    // 拒绝策略\r\n    private RejectPolicy rejectPolicy;\r\n\r\n    // 线程对象\r\n    class Worker extends Thread {\r\n\r\n        private Runnable task;\r\n\r\n        public Worker(Runnable runnable) {\r\n            this.task = runnable;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            // 就是线程把当前分配的任务做完，然后还要去阻塞队列找活干，没活就退出\r\n            // taks 如果不为空就执行然后讲其置为空，后续再次进入循环后会从阻塞队列中再次取出task，\r\n            // 如果不为空就继续执行，但是因为take死等，会导致无法结束\r\n            // 使用了这个超时等的方法，当无法取出时就会退出程序\r\n            while (task != null || (task = taskQueue.poll(timeout,unit)) != null) {\r\n                try {\r\n                    log.debug(\"开始执行任务\");\r\n                    Thread.sleep(1000);\r\n                    task.run();\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                } finally {\r\n                    task = null;\r\n                }\r\n            }\r\n            // 当没有任务可执行，线程自动销毁，由于这是根据对象来销毁，且hashset无序，所以这里无需保证其的线程安全。\r\n            workerSet.remove(this);\r\n        }\r\n    }\r\n\r\n\r\n    public ThreadPool(int capacity, int coreNum, long timeout, TimeUnit unit,RejectPolicy rejectPolicy) {\r\n        this.capacity = capacity;\r\n        this.coreNum = coreNum;\r\n        this.timeout = timeout;\r\n        this.unit = unit;\r\n        this.taskQueue = new TaskQueue<>(capacity);\r\n        this.rejectPolicy = rejectPolicy;\r\n    }\r\n\r\n    /**\r\n     * 当线程数大于核心数，就将任务放入阻塞队列\r\n     * 否则创建线程进行处理\r\n     *\r\n     * @param runnable\r\n     */\r\n    public void execute(Runnable runnable) {\r\n        // 需要synchronized关键字控制多线程下对执行方法的执行，保证共享变量workerSet安全。\r\n        synchronized (workerSet) {\r\n            // 如果已经存在的工作线程已经大于核心数，就不适合在进行创建线程了，创太多线程对于执行并不会加快，反而会因为线程不断切换而拖累CPU的执行。\r\n            if (workerSet.size() >= coreNum) {\r\n                taskQueue.push(runnable);\r\n            } else {\r\n                // 如果工作线程小于核心数就可创建一个worker线程来工作\r\n                Worker worker = new Worker(runnable);\r\n                workerSet.add(worker);\r\n                worker.start();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 测试类\r\n\r\n```Java\r\n@Slf4j\r\npublic class MyThreadPool {\r\n\r\n    public static void main(String[] args) {\r\n        ThreadPool threadPool = new ThreadPool(3,2,1,TimeUnit.SECONDS,(taskQueue,task)->{\r\n            taskQueue.push(task);\r\n        });\r\n        for (int i = 0; i < 10; i++) {\r\n            int j = i;\r\n            threadPool.execute(() -> {\r\n                log.debug(\"任务{}\", j);\r\n            });\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 优化---拒绝策略\r\n\r\n我们没有进行优化的就是当任务太多导致阻塞线程也满了，此时任务线程就会进行阻塞，直到等到有人在线程池中取走任务。也就是push方法，我们在旧的方法中仍采用的是死等的方法。\r\n\r\n但是方法中有很多死等，超时等，放弃任务，抛出异常，让调用者自己执行任务等等方法。\r\n\r\n我们就可用讲其进行抽象，把操作交给调用者。\r\n\r\n定义了如下的函数式接口，即为拒绝策略。\r\n\r\n```Java\r\n@FunctionalInterface\r\ninterface RejectPolicy<T>{\r\n    void reject(TaskQueue<T> taskQueue,T task);\r\n}\r\n```\r\n\r\n将在TaskQueue任务队列中定义不同的策略，我们只要传入这个函数式接口的实现对象就可用实现定制拒绝的策略。\r\n\r\n在TaskQueue类添加一个方法，用来调用拒绝策略\r\n\r\n```Java\r\npublic void tryAndAdd(T task,RejectPolicy rejectPolicy){\r\n    lock.lock();\r\n    try {\r\n        if (deque.size() >= capacity) {\r\n            rejectPolicy.reject(this,task);\r\n        }else{\r\n            log.debug(\"添加任务\");\r\n            deque.offerLast(task);\r\n            emptyWaitSet.signal();\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}\r\n```\r\n\r\n更改了构造方法的线程池类，这样就可用传入一个自定义的拒绝策略。\r\n\r\n```Java\r\n@Slf4j\r\nclass ThreadPool {\r\n    // 阻塞队列大小\r\n    private int capacity;\r\n    // 阻塞队列\r\n    private TaskQueue<Runnable> taskQueue;\r\n    // 工作线程\r\n    private HashSet<Worker> workerSet = new HashSet<>();\r\n    // 核心数\r\n    private int coreNum;\r\n    // 超时等待时间\r\n    private long timeout;\r\n    // 超时等待单位\r\n    private TimeUnit unit;\r\n    // 拒绝策略\r\n    private RejectPolicy rejectPolicy;\r\n\r\n    // 线程对象\r\n    class Worker extends Thread {\r\n\r\n        private Runnable task;\r\n\r\n        public Worker(Runnable runnable) {\r\n            this.task = runnable;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            while (task != null || (task = taskQueue.poll(timeout,unit)) != null) {\r\n                try {\r\n                    log.debug(\"开始执行任务\");\r\n                    Thread.sleep(1000);\r\n                    task.run();\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                } finally {\r\n                    task = null;\r\n                }\r\n            }\r\n            workerSet.remove(this);\r\n        }\r\n    }\r\n\r\n\r\n    public ThreadPool(int capacity, int coreNum, long timeout, TimeUnit unit,RejectPolicy rejectPolicy) {\r\n        this.capacity = capacity;\r\n        this.coreNum = coreNum;\r\n        this.timeout = timeout;\r\n        this.unit = unit;\r\n        this.taskQueue = new TaskQueue<>(capacity);\r\n        this.rejectPolicy = rejectPolicy;\r\n    }\r\n\r\n    /**\r\n     * 当线程数大于核心数，就将任务放入阻塞队列\r\n     * 否则创建线程进行处理\r\n     *\r\n     * @param runnable\r\n     */\r\n    public void execute(Runnable runnable) {\r\n        synchronized (workerSet) {\r\n            if (workerSet.size() >= coreNum) {\r\n                taskQueue.tryAndAdd(runnable,rejectPolicy);\r\n            } else {\r\n                Worker worker = new Worker(runnable);\r\n                workerSet.add(worker);\r\n                worker.start();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n将启动类修改如下\r\n\r\n```Java\r\n@Slf4j\r\npublic class MyThreadPool {\r\n\r\n    public static void main(String[] args) {\r\n        ThreadPool threadPool = new ThreadPool(3,2,1,TimeUnit.SECONDS,(taskQueue,task)->{\r\n            // 采用死等的方法，当然我们可用在taskQueue中定义更多的方法让调用者选择\r\n            taskQueue.push(task);\r\n        });\r\n        for (int i = 0; i < 10; i++) {\r\n            int j = i;\r\n            threadPool.execute(() -> {\r\n                log.debug(\"任务{}\", j);\r\n            });\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n这样我们就完成了自定义的线程池。', 'a1c2c1150add8182cb2c4389cfdae0df', '2023-01-27 19:31:13', '2023-02-03 03:00:00', '2', 8, 0, 0, 1, NULL);
INSERT INTO `wf_article` VALUES ('922c7398d064fefc907685a00bc1123d', 'JAVA（asList方法）', 'http://resource.duizhangz.cn//FqhrHawMGXoRRBWx-NKMp4wqfOT4', '前几天在看别人的项目的时候，发现一个问题，简单复现一下这个问题', '# 发现问题\r\n\r\n前几天在看别人的项目的时候，发现一个问题，简单复现一下这个问题\r\n\r\n```java\r\n// 注意这是一个Integer对象的数组哦\r\nInteger[] arr = new Integer[]{9999,88,77};\r\nList<Integer> list = Arrays.asList(arr);\r\n// 执行以下操作，有问题么？\r\nlist.add(1);\r\nlist.remove(0);\r\n```\r\n\r\n好的，如果你觉得没错，和我刚开始的想法一致。在我没有认真学习这个asList方法时，天真的以为没有问题，顾名思义啊，就是把数组转换成List呗。\r\n\r\n```java\r\n// 恭喜，喜提报错，如果是这样测试该找你麻烦了，/(ㄒoㄒ)/~~ \r\nException in thread \"main\" java.lang.UnsupportedOperationException\r\n	at java.util.AbstractList.add(AbstractList.java:148)\r\n	at java.util.AbstractList.add(AbstractList.java:108)\r\n	at TestForAsList.main(TestForAsList.java:13)\r\n```\r\n\r\n废话不多说，我们直接进源码里面看看。\r\n\r\n```Java\r\n@SafeVarargs\r\n@SuppressWarnings(\"varargs\")\r\npublic static <T> List<T> asList(T... a) {\r\n    return new ArrayList<>(a);  // 看起来没有任何异常，emm。然而呢，这个ArrayList并不是Java.util包下的ArrayList，而是一个在Arrays下实现的内部类。\r\n}\r\n```\r\n\r\n![1662390040619](javaAsList.assets/1662390040619.png)\r\n\r\n我们发现这个静态内部类里面并没有实现List的add和remove方法。那么子类将延用父类AbstractList的方法实现，这个继承应没有什么问题。\r\n\r\n```java\r\n// 我们进入这个父类的实现，发现了报错的根源。。\r\npublic abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\r\n    \r\n	public void add(int index, E element) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n\r\n\r\n    public E remove(int index) {\r\n        throw new UnsupportedOperationException();\r\n    }\r\n}\r\n```\r\n\r\n总结：\r\n\r\n究其原因，就是这个asList方法返回的是一个内部类，只实现了一些遍历以及更新的方法。下次使用它的时候需要注意一下。\r\n\r\n\r\n\r\n# 扩展知识点\r\n\r\n## 数组值的变化\r\n\r\n然后我就发现了这个很有意思的点，就是这个Arrays包下的ArrayList用的是构造器传进来的数组，并不像我们原来认为的ArrayList的那样会拷贝数组然后创建一个新的数组。\r\n\r\n这意味着我们在对这个List进行set的改动时，我们同时会**更改原数组的值**。\r\n\r\n```java\r\npublic static void main(String[] args) {\r\n        Integer[] arr = new Integer[]{9999,88,77};\r\n        List<Integer> list = Arrays.asList(arr);\r\n        \r\n        list.set(1,0);\r\n        System.out.println(list.get(1));  // 输出0\r\n        System.out.println(arr[1]);  // 同样也输出了0\r\n}\r\n```\r\n\r\n\r\n\r\n## int[]数组\r\n\r\n我们都知道int是基本数据类型，如果我们向asList()方法里面传入一个int[]数组会发生什么呢？\r\n\r\n我们知道泛型的话需要的是对象类型，基础数据类型是不能作为泛型的。\r\n\r\n```java\r\n// 此时int[]会作为一个对象类型，然后转换为list。此时长度为1，且可以正常的取出来作为list元素\r\npublic static void main(String[] args) {\r\n        int[] arr = new int[]{9999,88,77};\r\n        List<int[]> list = Arrays.asList(arr);\r\n        System.out.println(list.size());\r\n        System.out.println(list.get(0)[0]);\r\n        System.out.println(list.get(0)[1]);\r\n        System.out.println(list.get(0)[2]);\r\n}\r\n```\r\n\r\n\r\n\r\n好了，asList()方法就学废了。一天学废一个小知识/dog', '2ec80b30411dee0f3c4f98debf36da48', '2023-02-23 00:41:46', '2023-02-23 02:00:00', '2', 2, 0, 0, 1, NULL);
INSERT INTO `wf_article` VALUES ('944af2225b33f9c7b4af5ffdc2921ca0', 'Eureka服务注册中心以及服务发现', NULL, 'Eureka服务注册中心以及服务发现Eureka服务注册中心以及服务发现Eureka服务注册中心以及服务发现Eureka服务注册中心以及服务发现', '\r\n\r\n## Eureka服务注册中心以及服务发现\r\n\r\n![1](Eureka.assets/1.png)\r\n\r\n首先上来就是这个Eureka的架构图。\r\n\r\nEureka分为Server端和client端。微服务消费者和微服务提供者都属于Eureka client端。我们创建Eureka server端和client端，server端具有提供服务发现的能力，client端启动时向serve端发送注册请求，server端将会存储client端发送的注册信息（IP，实例id，端口等等），当client端连接server端后每隔一段时间会向server端发送心跳报文，证明自己还活着。\r\n\r\n同时server端还具备自我保护的机制，当client端没有及时向server端发送心跳报文，server端并直接不会将client删除，而是保存一段时间，直到client再次发送心跳请求，防止client端因为一些延迟导致心跳报文未能及时发送或到达，而被server端删除注册信息。\r\n\r\n与此同时client端也会缓存server端的注册信息，这样当单机server或者集群server都挂掉server也能相互找到。\r\n\r\n这是我一上来学SpringCloud就学习到的知识，于是乎我很懵逼，我提出了这样一个疑问为什么需要一个消费者和提供者，我直接调提供者不就好了？于是乎我百度，有了以下解释。\r\n\r\n#### 疑问：为什么需要一个消费者和提供者\r\n\r\n消费者是轻量的，在学习中消费者是通过RestTemplate这个对象注入实现去找到服务提供者。这样来说消费者是轻量的，而服务提供者是重量的，这样消费者能够通过server端的服务中心找到注册的服务提供者（服务提供者集群的情况下会去轮询），找到可用的合适的提供者（`这一切都是在消费者本地实现的负载均衡`）。如果没有消费者，直接调用服务提供者，是没办法实现负载均衡的。\r\n\r\n简单来说，消费者能够通过服务中心server端去寻找到已在服务中心注册的服务提供者，服务中心负责存储存活服务的信息，让消费者去做到负载均衡得到操作。\r\n\r\n\r\n\r\n----\r\n\r\n\r\n\r\n### 以下就是怎么做\r\n\r\n#### server端服务注册\r\n\r\n1.导入依赖\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\r\n</dependency>\r\n```\r\n\r\n2.配置application.yaml文件\r\n\r\n```yaml\r\nserver:\r\n  port: 7001\r\n\r\neureka:\r\n  instance:\r\n    hostname: eureka1.com  # eureka服务端的实例名称\r\n  client:\r\n    register-with-eureka: false   # 表示不向注册中滚注册自己\r\n    fetch-registry: false\r\n    service-url:\r\n      defaultZone: http://eureka2.com:7002/eureka/    # 向另外一个server发现自己，server端集群\r\n```\r\n\r\n3.启动类添加注解\r\n\r\n```Java\r\n@SpringBootApplication\r\n@EnableEurekaServer    //该注解启动即Server端\r\npublic class Eureka7001Main {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(Eureka7001Main.class);\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n#### client端服务注册\r\n\r\n1.导入依赖\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.springframework.cloud</groupId>\r\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\r\n</dependency>\r\n```\r\n\r\n2.配置application.yaml\r\n\r\n```yaml\r\nspring:\r\n  application:\r\n    name: cloud-payment-service    # 服务提供者集群的话需要服务名字是一样的\r\neureka:\r\n  client:\r\n    register-with-eureka: true   # 注册到Eureka客户端\r\n    fetch-registry: true   # 是否从服务端抓取注册信息，默认为true，单节点无所谓，集群必须设置为true才嗯那个配合ribbon使用负载均衡\r\n    service-url:\r\n      #      defaultZone: http://localhost:7001/eureka\r\n      defaultZone: http://eureka1.com:7001/eureka,http://eureka2.com:7002/eureka\r\n  instance:\r\n    instance-id: payment8001\r\n    prefer-ip-address: true  #  鼠标hover显示IP\r\n```\r\n\r\n3.启动类添加注解\r\n\r\n```java\r\n@SpringBootApplication\r\n@MapperScan(\"com.zhf.mapper\")\r\n@EnableEurekaClient\r\npublic class PaymentMain8001 {\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(PaymentMain8001.class);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n#### 消费者开启负载均衡\r\n\r\n添加注解\r\n\r\n```java\r\n@Configuration\r\npublic class ApplicationContextConfig {\r\n\r\n    @Bean\r\n    @LoadBalanced   // 开启负载均衡\r\n    public RestTemplate getRestTemplate(){\r\n        return new RestTemplate();\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n#### 服务发现Discovery\r\n\r\n服务发现即向服务中心发出请求，请求服务中心的信息，获得注册中心服务的信息。\r\n\r\n1.注入Bean\r\n\r\n```Java\r\n@Resource\r\nprivate DiscoveryClient discoveryClient;\r\n```\r\n\r\n2.方法使用获得服务信息\r\n\r\n```Java\r\nList<String> services = discoveryClient.getServices();\r\nservices.forEach(str->{\r\n    log.info(\"*******\" + str);\r\n});\r\nList<ServiceInstance> instances = discoveryClient.getInstances(\"CLOUD-PAYMENT-SERVICE0\");\r\nfor (ServiceInstance instance : instances) {\r\n    System.out.println(\"instance.getPort() = \" + instance.getPort());\r\n    System.out.println(\"instance.getInstanceId() = \" + instance.getInstanceId());\r\n}\r\nreturn discoveryClient;\r\n```\r\n\r\n', 'a1c2c1150add8182cb2c4389cfdae0df', '2023-01-18 02:20:02', NULL, '2', 0, 0, 0, 1, NULL);
INSERT INTO `wf_article` VALUES ('c3f9b85a896a3bad2c5e3eddf5b57449', 'JUC自定义线程池练习', 'http://resource.duizhangz.cn//FqhrHawMGXoRRBWx-NKMp4wqfOT4', 'JUC自定义线程池练习JUC自定义线程池练习JUC自定义线程池练习JUC自定义线程池练习JUC自定义线程池练习', '## JUC自定义线程池练习\r\n\r\n![自定义线程池执行流程](JUC线程池练习.assets/自定义线程池执行流程.png)\r\n\r\n首先上面该线程池的大致流程\r\n\r\n### 自定义阻塞队列\r\n\r\n* 首先定义一个双向的队列和锁一定两个等待的condition\r\n* 本类用lock来控制多线程下的流程执行\r\n* take和push方法就是死等，调用await就是等，后面优化为限时等待\r\n* take调用后取出阻塞队列的task后会调用fullWaitSet的signal方法来唤醒因为阻塞队列满了的线程将task放入阻塞队列。\r\n\r\n```Java\r\n@Slf4j\r\nclass TaskQueue<T> {\r\n\r\n    // 双向的阻塞队列\r\n    private Deque<T> deque;\r\n    // 队列最大容量\r\n    private int capacity;\r\n\r\n    // 锁\r\n    private ReentrantLock lock = new ReentrantLock();\r\n    // 消费者任务池空的等待队列\r\n    private Condition emptyWaitSet = lock.newCondition();\r\n    // 生产者任务池满的等待队列\r\n    private Condition fullWaitSet = lock.newCondition();\r\n\r\n\r\n    public TaskQueue(int capacity) {\r\n        this.capacity = capacity;\r\n        deque = new ArrayDeque<>(capacity);\r\n    }\r\n\r\n    // 死等take，即从阻塞队列取出任务\r\n    public T take() {\r\n        lock.lock();\r\n        try {\r\n            while (deque.isEmpty()) {\r\n                try {\r\n                    emptyWaitSet.await();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            log.debug(\"取走任务\");\r\n            T task = deque.pollFirst();\r\n            fullWaitSet.signal();\r\n            return task;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    // 线程添加任务，属于是死等添加\r\n    public void push(T task) {\r\n        lock.lock();\r\n        try {\r\n            while (deque.size() >= capacity) {\r\n                try {\r\n                    fullWaitSet.await();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            log.debug(\"添加任务\");\r\n            deque.offerLast(task);\r\n            emptyWaitSet.signal();\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public int getSize() {\r\n        lock.lock();\r\n        try {\r\n            return deque.size();\r\n        }finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 优化，死等优化为超时等\r\n\r\n* awaitNanos方法返回的是等待的剩余时间，如果已经等了base时间就会返回0，如果没有就会返回大于0即还没有等待的时间，防止虚假唤醒导致重新等待时间加长。当然在本题的设计中不会出现虚假唤醒的情况。\r\n\r\n```Java\r\npublic T poll(Long timeout,TimeUnit unit) {\r\n    lock.lock();\r\n    try {\r\n        long base = unit.toNanos(timeout);\r\n        while (deque.isEmpty()) {\r\n            try {\r\n                if (base <= 0){\r\n                    return null;\r\n                }\r\n                base = emptyWaitSet.awaitNanos(base);  // 返回还剩下的时间\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        log.debug(\"取走任务\");\r\n        T task = deque.pollFirst();\r\n        fullWaitSet.signal();\r\n        return task;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}\r\n```\r\n\r\n### 线程池类\r\n\r\n* 成员变量如下，对于Worker就工作线程\r\n\r\n```Java\r\n@Slf4j\r\nclass ThreadPool {\r\n    // 阻塞队列大小\r\n    private int capacity;\r\n    // 阻塞队列\r\n    private TaskQueue<Runnable> taskQueue;\r\n    // 工作线程\r\n    private HashSet<Worker> workerSet = new HashSet<>();\r\n    // 核心数\r\n    private int coreNum;\r\n    // 超时等待时间\r\n    private long timeout;\r\n    // 超时等待单位\r\n    private TimeUnit unit;\r\n    // 拒绝策略\r\n    private RejectPolicy rejectPolicy;\r\n\r\n    // 线程对象\r\n    class Worker extends Thread {\r\n\r\n        private Runnable task;\r\n\r\n        public Worker(Runnable runnable) {\r\n            this.task = runnable;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            // 就是线程把当前分配的任务做完，然后还要去阻塞队列找活干，没活就退出\r\n            // taks 如果不为空就执行然后讲其置为空，后续再次进入循环后会从阻塞队列中再次取出task，\r\n            // 如果不为空就继续执行，但是因为take死等，会导致无法结束\r\n            // 使用了这个超时等的方法，当无法取出时就会退出程序\r\n            while (task != null || (task = taskQueue.poll(timeout,unit)) != null) {\r\n                try {\r\n                    log.debug(\"开始执行任务\");\r\n                    Thread.sleep(1000);\r\n                    task.run();\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                } finally {\r\n                    task = null;\r\n                }\r\n            }\r\n            // 当没有任务可执行，线程自动销毁，由于这是根据对象来销毁，且hashset无序，所以这里无需保证其的线程安全。\r\n            workerSet.remove(this);\r\n        }\r\n    }\r\n\r\n\r\n    public ThreadPool(int capacity, int coreNum, long timeout, TimeUnit unit,RejectPolicy rejectPolicy) {\r\n        this.capacity = capacity;\r\n        this.coreNum = coreNum;\r\n        this.timeout = timeout;\r\n        this.unit = unit;\r\n        this.taskQueue = new TaskQueue<>(capacity);\r\n        this.rejectPolicy = rejectPolicy;\r\n    }\r\n\r\n    /**\r\n     * 当线程数大于核心数，就将任务放入阻塞队列\r\n     * 否则创建线程进行处理\r\n     *\r\n     * @param runnable\r\n     */\r\n    public void execute(Runnable runnable) {\r\n        // 需要synchronized关键字控制多线程下对执行方法的执行，保证共享变量workerSet安全。\r\n        synchronized (workerSet) {\r\n            // 如果已经存在的工作线程已经大于核心数，就不适合在进行创建线程了，创太多线程对于执行并不会加快，反而会因为线程不断切换而拖累CPU的执行。\r\n            if (workerSet.size() >= coreNum) {\r\n                taskQueue.push(runnable);\r\n            } else {\r\n                // 如果工作线程小于核心数就可创建一个worker线程来工作\r\n                Worker worker = new Worker(runnable);\r\n                workerSet.add(worker);\r\n                worker.start();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 测试类\r\n\r\n```Java\r\n@Slf4j\r\npublic class MyThreadPool {\r\n\r\n    public static void main(String[] args) {\r\n        ThreadPool threadPool = new ThreadPool(3,2,1,TimeUnit.SECONDS,(taskQueue,task)->{\r\n            taskQueue.push(task);\r\n        });\r\n        for (int i = 0; i < 10; i++) {\r\n            int j = i;\r\n            threadPool.execute(() -> {\r\n                log.debug(\"任务{}\", j);\r\n            });\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 优化---拒绝策略\r\n\r\n我们没有进行优化的就是当任务太多导致阻塞线程也满了，此时任务线程就会进行阻塞，直到等到有人在线程池中取走任务。也就是push方法，我们在旧的方法中仍采用的是死等的方法。\r\n\r\n但是方法中有很多死等，超时等，放弃任务，抛出异常，让调用者自己执行任务等等方法。\r\n\r\n我们就可用讲其进行抽象，把操作交给调用者。\r\n\r\n定义了如下的函数式接口，即为拒绝策略。\r\n\r\n```Java\r\n@FunctionalInterface\r\ninterface RejectPolicy<T>{\r\n    void reject(TaskQueue<T> taskQueue,T task);\r\n}\r\n```\r\n\r\n将在TaskQueue任务队列中定义不同的策略，我们只要传入这个函数式接口的实现对象就可用实现定制拒绝的策略。\r\n\r\n在TaskQueue类添加一个方法，用来调用拒绝策略\r\n\r\n```Java\r\npublic void tryAndAdd(T task,RejectPolicy rejectPolicy){\r\n    lock.lock();\r\n    try {\r\n        if (deque.size() >= capacity) {\r\n            rejectPolicy.reject(this,task);\r\n        }else{\r\n            log.debug(\"添加任务\");\r\n            deque.offerLast(task);\r\n            emptyWaitSet.signal();\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}\r\n```\r\n\r\n更改了构造方法的线程池类，这样就可用传入一个自定义的拒绝策略。\r\n\r\n```Java\r\n@Slf4j\r\nclass ThreadPool {\r\n    // 阻塞队列大小\r\n    private int capacity;\r\n    // 阻塞队列\r\n    private TaskQueue<Runnable> taskQueue;\r\n    // 工作线程\r\n    private HashSet<Worker> workerSet = new HashSet<>();\r\n    // 核心数\r\n    private int coreNum;\r\n    // 超时等待时间\r\n    private long timeout;\r\n    // 超时等待单位\r\n    private TimeUnit unit;\r\n    // 拒绝策略\r\n    private RejectPolicy rejectPolicy;\r\n\r\n    // 线程对象\r\n    class Worker extends Thread {\r\n\r\n        private Runnable task;\r\n\r\n        public Worker(Runnable runnable) {\r\n            this.task = runnable;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            while (task != null || (task = taskQueue.poll(timeout,unit)) != null) {\r\n                try {\r\n                    log.debug(\"开始执行任务\");\r\n                    Thread.sleep(1000);\r\n                    task.run();\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                } finally {\r\n                    task = null;\r\n                }\r\n            }\r\n            workerSet.remove(this);\r\n        }\r\n    }\r\n\r\n\r\n    public ThreadPool(int capacity, int coreNum, long timeout, TimeUnit unit,RejectPolicy rejectPolicy) {\r\n        this.capacity = capacity;\r\n        this.coreNum = coreNum;\r\n        this.timeout = timeout;\r\n        this.unit = unit;\r\n        this.taskQueue = new TaskQueue<>(capacity);\r\n        this.rejectPolicy = rejectPolicy;\r\n    }\r\n\r\n    /**\r\n     * 当线程数大于核心数，就将任务放入阻塞队列\r\n     * 否则创建线程进行处理\r\n     *\r\n     * @param runnable\r\n     */\r\n    public void execute(Runnable runnable) {\r\n        synchronized (workerSet) {\r\n            if (workerSet.size() >= coreNum) {\r\n                taskQueue.tryAndAdd(runnable,rejectPolicy);\r\n            } else {\r\n                Worker worker = new Worker(runnable);\r\n                workerSet.add(worker);\r\n                worker.start();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n将启动类修改如下\r\n\r\n```Java\r\n@Slf4j\r\npublic class MyThreadPool {\r\n\r\n    public static void main(String[] args) {\r\n        ThreadPool threadPool = new ThreadPool(3,2,1,TimeUnit.SECONDS,(taskQueue,task)->{\r\n            // 采用死等的方法，当然我们可用在taskQueue中定义更多的方法让调用者选择\r\n            taskQueue.push(task);\r\n        });\r\n        for (int i = 0; i < 10; i++) {\r\n            int j = i;\r\n            threadPool.execute(() -> {\r\n                log.debug(\"任务{}\", j);\r\n            });\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n这样我们就完成了自定义的线程池。', 'a1c2c1150add8182cb2c4389cfdae0df', '2023-01-27 19:34:46', '2023-02-26 00:30:00', '2', 366, 1, 0, 1, NULL);
INSERT INTO `wf_article` VALUES ('e35aa8192453a4238d57e7075ffee047', '2021在阿里云服务器下centos7安装JDK8', NULL, '2021在阿里云服务器下centos7安装JDK82021在阿里云服务器下centos7安装JDK82021在阿里云服务器下centos7安装JDK8', '\n\n## 首先去oracle官网下载JDK\n\n我下载的是JDK8的链接https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html\n\n下拉在下载列表中找到以下选项Linux ×64 RPM Package\n\n![jdk1](https://gitee.com/captain-66/picpath/raw/master/mdimg/jdk1.png)\n\n登陆下载即可。\n\n\n\n## 解压安装JDK\n\n把下载好的rpm包放到服务器上面。(我用的是XFTP，还有Xshell这些软件不必多说)\n\n\n\n### 第一步\n\n到服务器上首先检查JDK环境，卸载服务器原有的JDK。\n\n```xml\n#卸载原有的JDK，执行以下指令\nrpm -qa|grep jdk\n#若存在原有的JDK此时在执行命令后会出现名字,复制\n#就是把下面的java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64换成复制的内容就可以清除原有的JDK\nrpm -e --nodeps java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64\n```\n\n\n\n\n\n### 第二步\n\n```xml\n#执行安装指令,到rpm包的目录下,解压对应的包即可，输入jdk按下tab键会自动补全名字\nrpm -ivh jdk\n```\n\n![jdk2](https://gitee.com/captain-66/picpath/raw/master/mdimg/jdk2.png)\n\n出现以上没有出现error就算是是安装成功了。\n\n\n\n\n\n### 第三步\n\n首先把/usr/java/下jdk的名称复制一下，我的就是下面JAVA_HOME那名字。\n\n配置环境变量\n\n```xml \n#修改profile文件\nvim /etc/profile\n```\n\n进入后按下ins键或i键进入修改模式。\n\n到文件最底下加入绿色光标以下配置，除JAVA_HOME的名字，其他基本一致。\n\n![jdk3](https://gitee.com/captain-66/picpath/raw/master/mdimg/jdk3.png)\n\n输入结束按ESC，输入:wq，回车，保存退出。\n\n```xml\n#更新profile文件\nsource /etc/profile\n```\n\n\n\n\n\n### 检查JAVA配置是否正确\n\n在命令行输入java,javac,java -version等指令查看，若出现相应内容就是安装成功了！！。\n\n', 'a1c2c1150add8182cb2c4389cfdae0df', '2023-01-18 02:22:02', NULL, '2', 0, 0, 0, 1, NULL);
INSERT INTO `wf_article` VALUES ('e8d9443c265e081b1ad48d1478102420', '前几天在看别人的项目的时候，发现一个问题，简单复现一下这个问题', NULL, '前几天在看别人的项目的时候，发现一个问题，简单复现一下这个问题前几天在看别人的项目的时候，发现一个问题，简单复现一下这个问题', '前几天在看别人的项目的时候，发现一个问题，简单复现一下这个问题\n\n```java\n// 注意这是一个Integer对象的数组哦\nInteger[] arr = new Integer[]{9999,88,77};\nList<Integer> list = Arrays.asList(arr);\n// 执行以下操作，有问题么？\nlist.add(1);\nlist.remove(0);\n```\n\n好的，如果你觉得没错，和我刚开始的想法一致。在我没有认真学习这个asList方法时，天真的以为没有问题，顾名思义啊，就是把数组转换成List呗。\n\n```java\n// 恭喜，喜提报错，如果是这样测试该找你麻烦了，/(ㄒoㄒ)/~~ \nException in thread \"main\" java.lang.UnsupportedOperationException\n	at java.util.AbstractList.add(AbstractList.java:148)\n	at java.util.AbstractList.add(AbstractList.java:108)\n	at TestForAsList.main(TestForAsList.java:13)\n```\n\n废话不多说，我们直接进源码里面看看。\n\n```Java\n@SafeVarargs\n@SuppressWarnings(\"varargs\")\npublic static <T> List<T> asList(T... a) {\n    return new ArrayList<>(a);  // 看起来没有任何异常，emm。然而呢，这个ArrayList并不是Java.util包下的ArrayList，而是一个在Arrays下实现的内部类。\n}\n```\n\n![1662390040619](javaAsList.assets/1662390040619.png)\n\n我们发现这个静态内部类里面并没有实现List的add和remove方法。那么子类将延用父类AbstractList的方法实现，这个继承应没有什么问题。\n\n```java\n// 我们进入这个父类的实现，发现了报错的根源。。\npublic abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {\n    \n	public void add(int index, E element) {\n        throw new UnsupportedOperationException();\n    }\n\n\n    public E remove(int index) {\n        throw new UnsupportedOperationException();\n    }\n}\n```\n\n总结：\n\n究其原因，就是这个asList方法返回的是一个内部类，只实现了一些遍历以及更新的方法。下次使用它的时候需要注意一下。\n\n\n\n# 扩展知识点\n\n## 数组值的变化\n\n然后我就发现了这个很有意思的点，就是这个Arrays包下的ArrayList用的是构造器传进来的数组，并不像我们原来认为的ArrayList的那样会拷贝数组然后创建一个新的数组。\n\n这意味着我们在对这个List进行set的改动时，我们同时会**更改原数组的值**。\n\n```java\npublic static void main(String[] args) {\n        Integer[] arr = new Integer[]{9999,88,77};\n        List<Integer> list = Arrays.asList(arr);\n        \n        list.set(1,0);\n        System.out.println(list.get(1));  // 输出0\n        System.out.println(arr[1]);  // 同样也输出了0\n}\n```\n\n\n\n## int[]数组\n\n我们都知道int是基本数据类型，如果我们向asList()方法里面传入一个int[]数组会发生什么呢？\n\n我们知道泛型的话需要的是对象类型，基础数据类型是不能作为泛型的。\n\n```java\n// 此时int[]会作为一个对象类型，然后转换为list。此时长度为1，且可以正常的取出来作为list元素\npublic static void main(String[] args) {\n        int[] arr = new int[]{9999,88,77};\n        List<int[]> list = Arrays.asList(arr);\n        System.out.println(list.size());\n        System.out.println(list.get(0)[0]);\n        System.out.println(list.get(0)[1]);\n        System.out.println(list.get(0)[2]);\n}\n```\n\n\n\n好了，asList()方法就学废了。一天学废一个小知识/dog', 'a1c2c1150add8182cb2c4389cfdae0df', '2023-01-18 02:21:02', '2023-02-25 23:30:00', '2', 13, 1, 0, 1, NULL);
INSERT INTO `wf_article` VALUES ('edf9e06084590e33298d2c29a09df9a6', 'JUC自定义线程池练习', 'http://resource.duizhangz.cn//FqhrHawMGXoRRBWx-NKMp4wqfOT4', 'JUC自定义线程池练习JUC自定义线程池练习JUC自定义线程池练习JUC自定义线程池练习JUC自定义线程池练习JUC自定义线程池练习', '## JUC自定义线程池练习\r\n\r\n![自定义线程池执行流程](JUC线程池练习.assets/自定义线程池执行流程.png)\r\n\r\n首先上面该线程池的大致流程\r\n\r\n### 自定义阻塞队列\r\n\r\n* 首先定义一个双向的队列和锁一定两个等待的condition\r\n* 本类用lock来控制多线程下的流程执行\r\n* take和push方法就是死等，调用await就是等，后面优化为限时等待\r\n* take调用后取出阻塞队列的task后会调用fullWaitSet的signal方法来唤醒因为阻塞队列满了的线程将task放入阻塞队列。\r\n\r\n```Java\r\n@Slf4j\r\nclass TaskQueue<T> {\r\n\r\n    // 双向的阻塞队列\r\n    private Deque<T> deque;\r\n    // 队列最大容量\r\n    private int capacity;\r\n\r\n    // 锁\r\n    private ReentrantLock lock = new ReentrantLock();\r\n    // 消费者任务池空的等待队列\r\n    private Condition emptyWaitSet = lock.newCondition();\r\n    // 生产者任务池满的等待队列\r\n    private Condition fullWaitSet = lock.newCondition();\r\n\r\n\r\n    public TaskQueue(int capacity) {\r\n        this.capacity = capacity;\r\n        deque = new ArrayDeque<>(capacity);\r\n    }\r\n\r\n    // 死等take，即从阻塞队列取出任务\r\n    public T take() {\r\n        lock.lock();\r\n        try {\r\n            while (deque.isEmpty()) {\r\n                try {\r\n                    emptyWaitSet.await();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            log.debug(\"取走任务\");\r\n            T task = deque.pollFirst();\r\n            fullWaitSet.signal();\r\n            return task;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    // 线程添加任务，属于是死等添加\r\n    public void push(T task) {\r\n        lock.lock();\r\n        try {\r\n            while (deque.size() >= capacity) {\r\n                try {\r\n                    fullWaitSet.await();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            log.debug(\"添加任务\");\r\n            deque.offerLast(task);\r\n            emptyWaitSet.signal();\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public int getSize() {\r\n        lock.lock();\r\n        try {\r\n            return deque.size();\r\n        }finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 优化，死等优化为超时等\r\n\r\n* awaitNanos方法返回的是等待的剩余时间，如果已经等了base时间就会返回0，如果没有就会返回大于0即还没有等待的时间，防止虚假唤醒导致重新等待时间加长。当然在本题的设计中不会出现虚假唤醒的情况。\r\n\r\n```Java\r\npublic T poll(Long timeout,TimeUnit unit) {\r\n    lock.lock();\r\n    try {\r\n        long base = unit.toNanos(timeout);\r\n        while (deque.isEmpty()) {\r\n            try {\r\n                if (base <= 0){\r\n                    return null;\r\n                }\r\n                base = emptyWaitSet.awaitNanos(base);  // 返回还剩下的时间\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        log.debug(\"取走任务\");\r\n        T task = deque.pollFirst();\r\n        fullWaitSet.signal();\r\n        return task;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}\r\n```\r\n\r\n### 线程池类\r\n\r\n* 成员变量如下，对于Worker就工作线程\r\n\r\n```Java\r\n@Slf4j\r\nclass ThreadPool {\r\n    // 阻塞队列大小\r\n    private int capacity;\r\n    // 阻塞队列\r\n    private TaskQueue<Runnable> taskQueue;\r\n    // 工作线程\r\n    private HashSet<Worker> workerSet = new HashSet<>();\r\n    // 核心数\r\n    private int coreNum;\r\n    // 超时等待时间\r\n    private long timeout;\r\n    // 超时等待单位\r\n    private TimeUnit unit;\r\n    // 拒绝策略\r\n    private RejectPolicy rejectPolicy;\r\n\r\n    // 线程对象\r\n    class Worker extends Thread {\r\n\r\n        private Runnable task;\r\n\r\n        public Worker(Runnable runnable) {\r\n            this.task = runnable;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            // 就是线程把当前分配的任务做完，然后还要去阻塞队列找活干，没活就退出\r\n            // taks 如果不为空就执行然后讲其置为空，后续再次进入循环后会从阻塞队列中再次取出task，\r\n            // 如果不为空就继续执行，但是因为take死等，会导致无法结束\r\n            // 使用了这个超时等的方法，当无法取出时就会退出程序\r\n            while (task != null || (task = taskQueue.poll(timeout,unit)) != null) {\r\n                try {\r\n                    log.debug(\"开始执行任务\");\r\n                    Thread.sleep(1000);\r\n                    task.run();\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                } finally {\r\n                    task = null;\r\n                }\r\n            }\r\n            // 当没有任务可执行，线程自动销毁，由于这是根据对象来销毁，且hashset无序，所以这里无需保证其的线程安全。\r\n            workerSet.remove(this);\r\n        }\r\n    }\r\n\r\n\r\n    public ThreadPool(int capacity, int coreNum, long timeout, TimeUnit unit,RejectPolicy rejectPolicy) {\r\n        this.capacity = capacity;\r\n        this.coreNum = coreNum;\r\n        this.timeout = timeout;\r\n        this.unit = unit;\r\n        this.taskQueue = new TaskQueue<>(capacity);\r\n        this.rejectPolicy = rejectPolicy;\r\n    }\r\n\r\n    /**\r\n     * 当线程数大于核心数，就将任务放入阻塞队列\r\n     * 否则创建线程进行处理\r\n     *\r\n     * @param runnable\r\n     */\r\n    public void execute(Runnable runnable) {\r\n        // 需要synchronized关键字控制多线程下对执行方法的执行，保证共享变量workerSet安全。\r\n        synchronized (workerSet) {\r\n            // 如果已经存在的工作线程已经大于核心数，就不适合在进行创建线程了，创太多线程对于执行并不会加快，反而会因为线程不断切换而拖累CPU的执行。\r\n            if (workerSet.size() >= coreNum) {\r\n                taskQueue.push(runnable);\r\n            } else {\r\n                // 如果工作线程小于核心数就可创建一个worker线程来工作\r\n                Worker worker = new Worker(runnable);\r\n                workerSet.add(worker);\r\n                worker.start();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 测试类\r\n\r\n```Java\r\n@Slf4j\r\npublic class MyThreadPool {\r\n\r\n    public static void main(String[] args) {\r\n        ThreadPool threadPool = new ThreadPool(3,2,1,TimeUnit.SECONDS,(taskQueue,task)->{\r\n            taskQueue.push(task);\r\n        });\r\n        for (int i = 0; i < 10; i++) {\r\n            int j = i;\r\n            threadPool.execute(() -> {\r\n                log.debug(\"任务{}\", j);\r\n            });\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 优化---拒绝策略\r\n\r\n我们没有进行优化的就是当任务太多导致阻塞线程也满了，此时任务线程就会进行阻塞，直到等到有人在线程池中取走任务。也就是push方法，我们在旧的方法中仍采用的是死等的方法。\r\n\r\n但是方法中有很多死等，超时等，放弃任务，抛出异常，让调用者自己执行任务等等方法。\r\n\r\n我们就可用讲其进行抽象，把操作交给调用者。\r\n\r\n定义了如下的函数式接口，即为拒绝策略。\r\n\r\n```Java\r\n@FunctionalInterface\r\ninterface RejectPolicy<T>{\r\n    void reject(TaskQueue<T> taskQueue,T task);\r\n}\r\n```\r\n\r\n将在TaskQueue任务队列中定义不同的策略，我们只要传入这个函数式接口的实现对象就可用实现定制拒绝的策略。\r\n\r\n在TaskQueue类添加一个方法，用来调用拒绝策略\r\n\r\n```Java\r\npublic void tryAndAdd(T task,RejectPolicy rejectPolicy){\r\n    lock.lock();\r\n    try {\r\n        if (deque.size() >= capacity) {\r\n            rejectPolicy.reject(this,task);\r\n        }else{\r\n            log.debug(\"添加任务\");\r\n            deque.offerLast(task);\r\n            emptyWaitSet.signal();\r\n        }\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}\r\n```\r\n\r\n更改了构造方法的线程池类，这样就可用传入一个自定义的拒绝策略。\r\n\r\n```Java\r\n@Slf4j\r\nclass ThreadPool {\r\n    // 阻塞队列大小\r\n    private int capacity;\r\n    // 阻塞队列\r\n    private TaskQueue<Runnable> taskQueue;\r\n    // 工作线程\r\n    private HashSet<Worker> workerSet = new HashSet<>();\r\n    // 核心数\r\n    private int coreNum;\r\n    // 超时等待时间\r\n    private long timeout;\r\n    // 超时等待单位\r\n    private TimeUnit unit;\r\n    // 拒绝策略\r\n    private RejectPolicy rejectPolicy;\r\n\r\n    // 线程对象\r\n    class Worker extends Thread {\r\n\r\n        private Runnable task;\r\n\r\n        public Worker(Runnable runnable) {\r\n            this.task = runnable;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            while (task != null || (task = taskQueue.poll(timeout,unit)) != null) {\r\n                try {\r\n                    log.debug(\"开始执行任务\");\r\n                    Thread.sleep(1000);\r\n                    task.run();\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                } finally {\r\n                    task = null;\r\n                }\r\n            }\r\n            workerSet.remove(this);\r\n        }\r\n    }\r\n\r\n\r\n    public ThreadPool(int capacity, int coreNum, long timeout, TimeUnit unit,RejectPolicy rejectPolicy) {\r\n        this.capacity = capacity;\r\n        this.coreNum = coreNum;\r\n        this.timeout = timeout;\r\n        this.unit = unit;\r\n        this.taskQueue = new TaskQueue<>(capacity);\r\n        this.rejectPolicy = rejectPolicy;\r\n    }\r\n\r\n    /**\r\n     * 当线程数大于核心数，就将任务放入阻塞队列\r\n     * 否则创建线程进行处理\r\n     *\r\n     * @param runnable\r\n     */\r\n    public void execute(Runnable runnable) {\r\n        synchronized (workerSet) {\r\n            if (workerSet.size() >= coreNum) {\r\n                taskQueue.tryAndAdd(runnable,rejectPolicy);\r\n            } else {\r\n                Worker worker = new Worker(runnable);\r\n                workerSet.add(worker);\r\n                worker.start();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n将启动类修改如下\r\n\r\n```Java\r\n@Slf4j\r\npublic class MyThreadPool {\r\n\r\n    public static void main(String[] args) {\r\n        ThreadPool threadPool = new ThreadPool(3,2,1,TimeUnit.SECONDS,(taskQueue,task)->{\r\n            // 采用死等的方法，当然我们可用在taskQueue中定义更多的方法让调用者选择\r\n            taskQueue.push(task);\r\n        });\r\n        for (int i = 0; i < 10; i++) {\r\n            int j = i;\r\n            threadPool.execute(() -> {\r\n                log.debug(\"任务{}\", j);\r\n            });\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n这样我们就完成了自定义的线程池。', 'a1c2c1150add8182cb2c4389cfdae0df', '2023-01-27 19:33:37', '2023-02-23 20:30:01', '2', 33, 0, 0, 1, NULL);

-- ----------------------------
-- Table structure for wf_article_click_relation
-- ----------------------------
DROP TABLE IF EXISTS `wf_article_click_relation`;
CREATE TABLE `wf_article_click_relation`  (
  `uuid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '主键',
  `user_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户ID',
  `article_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章ID',
  `state` tinyint NULL DEFAULT NULL COMMENT '点赞状态:(1:点击，2:取消)',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`uuid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of wf_article_click_relation
-- ----------------------------
INSERT INTO `wf_article_click_relation` VALUES ('2a7c17edd83e3961d9a3da141046a47f', '2ec80b30411dee0f3c4f98debf36da48', '2197f77c59b7cc80a5f9e73d1f7074c9', 1, '2023-02-23 20:13:53', '2023-02-23 20:13:53');
INSERT INTO `wf_article_click_relation` VALUES ('d42c4933e7c5b56e7c4be850e0c857bc', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', 1, '2023-01-30 01:36:07', '2023-02-03 03:32:26');
INSERT INTO `wf_article_click_relation` VALUES ('dece6d806f4ec306560f2843ab350bd8', '2ec80b30411dee0f3c4f98debf36da48', 'e8d9443c265e081b1ad48d1478102420', 1, '2023-02-25 23:22:54', '2023-02-25 23:22:54');

-- ----------------------------
-- Table structure for wf_article_comment
-- ----------------------------
DROP TABLE IF EXISTS `wf_article_comment`;
CREATE TABLE `wf_article_comment`  (
  `uuid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `comment` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '评论内容',
  `user_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '创建者id',
  `article_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章id',
  `parent_comment_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '父评论Id',
  `reply_comment_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '子回复的回复的id',
  `like_number` int NULL DEFAULT NULL COMMENT '点赞数',
  `is_del` int NULL DEFAULT NULL COMMENT '删除状态位0为真，1为已删除',
  `create_time` datetime NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  PRIMARY KEY (`uuid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of wf_article_comment
-- ----------------------------
INSERT INTO `wf_article_comment` VALUES ('0cc2a6d9208c70cc35f353a3d8c2efc8', '可以hello啊啊啊啊啊，赶紧hello', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', 'b171afb654a602a483ccd8e38529abb1', 'e192ec7a156da1d7e7410203fb052215', 0, 0, '2023-02-01 19:53:25', '2023-02-01 19:53:25');
INSERT INTO `wf_article_comment` VALUES ('1394e24c3e4e6bd9613f3b4e40f51f60', '111111111111111111', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', '569c50c13f04a13d3e5ca881f6a278f2', 'ce372320cbc1ac60eef63e7d3bdac975', 0, 0, '2023-02-01 22:06:44', '2023-02-01 22:06:44');
INSERT INTO `wf_article_comment` VALUES ('569c50c13f04a13d3e5ca881f6a278f2', 'test11111111', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', NULL, NULL, 1, 0, '2023-02-01 21:59:18', '2023-02-03 02:56:30');
INSERT INTO `wf_article_comment` VALUES ('57798c89aa1e81bce10e8899587e458f', '😁😁', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', NULL, NULL, 0, 0, '2023-02-11 00:33:35', '2023-02-11 00:33:35');
INSERT INTO `wf_article_comment` VALUES ('5789cc9950b267a66a2f958411e9571b', 'test1111', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', '8f5156ac5440f206f8a9bf9905881698', NULL, 0, 0, '2023-02-01 20:27:02', '2023-02-01 20:27:02');
INSERT INTO `wf_article_comment` VALUES ('5866cdb0e3031aed3b3452552c828148', '你不行啊啊啊', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', NULL, NULL, 0, 0, '2023-02-01 20:00:37', '2023-02-01 20:00:37');
INSERT INTO `wf_article_comment` VALUES ('58ea948b7780d3f5f7d82ff6ea14b976', '1113231', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', '569c50c13f04a13d3e5ca881f6a278f2', 'b69c7fc4724098651178a02ba88132fa', 0, 0, '2023-02-01 22:05:38', '2023-02-01 22:05:38');
INSERT INTO `wf_article_comment` VALUES ('6754c5d7cfecb94f724d7f9b85343bb3', 'hhhhhhhhhhhhhhhhhhhh', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', NULL, NULL, 0, 0, '2023-02-01 20:26:47', '2023-02-01 20:26:47');
INSERT INTO `wf_article_comment` VALUES ('72fd1a212ee2ba904bb815364929d4e6', '可以的说实话我喜欢', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', 'b171afb654a602a483ccd8e38529abb1', 'e192ec7a156da1d7e7410203fb052215', 0, 0, '2023-02-01 19:55:28', '2023-02-01 19:55:28');
INSERT INTO `wf_article_comment` VALUES ('8f5156ac5440f206f8a9bf9905881698', 'hello mother fucker', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', NULL, NULL, 0, 0, '2023-02-01 20:19:54', '2023-02-01 20:19:54');
INSERT INTO `wf_article_comment` VALUES ('8fdc60bebd30d82d07d5f44f85837b4a', '谁说不能hello的你告诉我？', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', 'b171afb654a602a483ccd8e38529abb1', 'e192ec7a156da1d7e7410203fb052215', 0, 0, '2023-02-01 03:07:40', '2023-02-01 03:07:40');
INSERT INTO `wf_article_comment` VALUES ('9ea2663ae7693d665d45e851081e606d', '4564543', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', '569c50c13f04a13d3e5ca881f6a278f2', 'ce372320cbc1ac60eef63e7d3bdac975', 0, 0, '2023-02-01 22:06:01', '2023-02-01 22:06:01');
INSERT INTO `wf_article_comment` VALUES ('b171afb654a602a483ccd8e38529abb1', 'hello world', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', '', '', 0, 0, '2023-02-01 03:04:41', '2023-02-01 03:04:41');
INSERT INTO `wf_article_comment` VALUES ('b69c7fc4724098651178a02ba88132fa', '11111', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', '569c50c13f04a13d3e5ca881f6a278f2', NULL, 1, 0, '2023-02-01 22:05:34', '2023-02-01 22:05:34');
INSERT INTO `wf_article_comment` VALUES ('ce372320cbc1ac60eef63e7d3bdac975', '4324324234', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', '569c50c13f04a13d3e5ca881f6a278f2', 'b69c7fc4724098651178a02ba88132fa', 1, 0, '2023-02-01 22:05:47', '2023-02-01 22:05:47');
INSERT INTO `wf_article_comment` VALUES ('e004f6f5335be4a9731d0d3333cad8c1', 'hello啊', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', NULL, NULL, 0, 0, '2023-02-01 19:24:21', '2023-02-01 19:24:21');
INSERT INTO `wf_article_comment` VALUES ('e192ec7a156da1d7e7410203fb052215', '不能hello啊，很烦', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', 'b171afb654a602a483ccd8e38529abb1', '', 0, 0, '2023-02-01 03:07:08', '2023-02-01 03:07:08');
INSERT INTO `wf_article_comment` VALUES ('f23541297f983266c3503bf7cf5058e8', '可以的', 'a1c2c1150add8182cb2c4389cfdae0df', 'c3f9b85a896a3bad2c5e3eddf5b57449', '57798c89aa1e81bce10e8899587e458f', NULL, 0, 0, '2023-02-26 00:19:52', '2023-02-26 00:19:52');
INSERT INTO `wf_article_comment` VALUES ('fa8363a8ce175c135fb2746c715c28a1', '😂😂', '2ec80b30411dee0f3c4f98debf36da48', 'c3f9b85a896a3bad2c5e3eddf5b57449', '57798c89aa1e81bce10e8899587e458f', 'f23541297f983266c3503bf7cf5058e8', 2, 0, '2023-02-26 00:22:26', '2023-02-26 00:29:39');

-- ----------------------------
-- Table structure for wf_article_comment_like_relation
-- ----------------------------
DROP TABLE IF EXISTS `wf_article_comment_like_relation`;
CREATE TABLE `wf_article_comment_like_relation`  (
  `uuid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `user_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户ID',
  `comment_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '评论ID',
  `state` tinyint NULL DEFAULT NULL COMMENT '点赞状态:(1:点击，2:取消)',
  `create_time` datetime NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  PRIMARY KEY (`uuid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of wf_article_comment_like_relation
-- ----------------------------
INSERT INTO `wf_article_comment_like_relation` VALUES ('00204c0245a5617aedf9f3f2e925fc4a', 'a1c2c1150add8182cb2c4389cfdae0df', 'fa8363a8ce175c135fb2746c715c28a1', 1, '2023-02-26 00:29:12', '2023-02-26 00:29:12');
INSERT INTO `wf_article_comment_like_relation` VALUES ('1d050e2a007fcc8979d33d9ea74c8596', '2ec80b30411dee0f3c4f98debf36da48', 'fa8363a8ce175c135fb2746c715c28a1', 1, '2023-02-26 00:29:39', '2023-02-26 00:29:39');
INSERT INTO `wf_article_comment_like_relation` VALUES ('2c98935e257e27ff554bd880ab21dcad', '2ec80b30411dee0f3c4f98debf36da48', '569c50c13f04a13d3e5ca881f6a278f2', 1, '2023-02-01 23:52:27', '2023-02-03 02:56:30');
INSERT INTO `wf_article_comment_like_relation` VALUES ('b05a26494759b00561a8ad5b1b607f1c', '2ec80b30411dee0f3c4f98debf36da48', 'ce372320cbc1ac60eef63e7d3bdac975', 1, '2023-02-02 00:32:53', '2023-02-02 00:32:53');
INSERT INTO `wf_article_comment_like_relation` VALUES ('fe12d3f46f08dd8e047f25f0609cccd5', '2ec80b30411dee0f3c4f98debf36da48', 'b69c7fc4724098651178a02ba88132fa', 1, '2023-02-01 23:57:47', '2023-02-01 23:57:47');

-- ----------------------------
-- Table structure for wf_article_label_relation
-- ----------------------------
DROP TABLE IF EXISTS `wf_article_label_relation`;
CREATE TABLE `wf_article_label_relation`  (
  `uuid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `article_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章id',
  `label_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '类别id',
  `create_time` datetime NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  PRIMARY KEY (`uuid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of wf_article_label_relation
-- ----------------------------
INSERT INTO `wf_article_label_relation` VALUES ('1619225807719710721', 'c3f9b85a896a3bad2c5e3eddf5b57449', '1', '2023-01-28 14:48:11', '2023-01-28 14:48:11');
INSERT INTO `wf_article_label_relation` VALUES ('1619225807719710722', 'c3f9b85a896a3bad2c5e3eddf5b57449', '4', '2023-01-28 14:48:11', '2023-01-28 14:48:11');
INSERT INTO `wf_article_label_relation` VALUES ('170eaf69d1da8b0ad049529576653d4d', '8de746f565f6ad0362fc0365db17ccc7', '1', '2023-01-27 19:31:13', '2023-01-27 19:31:13');
INSERT INTO `wf_article_label_relation` VALUES ('1ea326d7851a2fce13ccefb4624d1742', '4aa5086163e5c22a32873a0f7a4376db', '1', '2023-01-27 19:33:07', '2023-01-27 19:33:07');
INSERT INTO `wf_article_label_relation` VALUES ('7226e689be68b762ed5b0be6838ff56f', 'edf9e06084590e33298d2c29a09df9a6', '1', '2023-01-27 19:33:37', '2023-01-27 19:33:37');
INSERT INTO `wf_article_label_relation` VALUES ('b88aab13ff4a34b28cc7d369c7c3e6da', '922c7398d064fefc907685a00bc1123d', '1', '2023-02-23 00:41:46', '2023-02-23 00:41:46');

-- ----------------------------
-- Table structure for wf_article_store_list_relation
-- ----------------------------
DROP TABLE IF EXISTS `wf_article_store_list_relation`;
CREATE TABLE `wf_article_store_list_relation`  (
  `uuid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT 'uuid主键',
  `store_list_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '收藏夹ID',
  `article_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '文章ID',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`uuid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of wf_article_store_list_relation
-- ----------------------------
INSERT INTO `wf_article_store_list_relation` VALUES ('1620342802619981825', '1620119971030237186', 'c3f9b85a896a3bad2c5e3eddf5b57449', '2023-01-31 16:46:43', '2023-01-31 16:46:43');
INSERT INTO `wf_article_store_list_relation` VALUES ('1620356625972224001', '1620121316537864194', 'c3f9b85a896a3bad2c5e3eddf5b57449', '2023-01-31 17:41:39', '2023-01-31 17:41:39');
INSERT INTO `wf_article_store_list_relation` VALUES ('1620364733813514242', 'fa0dd3f21030253f7862c0e6edeb79ae', 'c3f9b85a896a3bad2c5e3eddf5b57449', '2023-01-31 18:13:52', '2023-01-31 18:13:52');

-- ----------------------------
-- Table structure for wf_im_record
-- ----------------------------
DROP TABLE IF EXISTS `wf_im_record`;
CREATE TABLE `wf_im_record`  (
  `uuid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `user_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '发送者ID',
  `to_user_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '被发送者ID',
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '发送内容',
  `create_time` datetime NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  PRIMARY KEY (`uuid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of wf_im_record
-- ----------------------------
INSERT INTO `wf_im_record` VALUES ('_zGpAa8QzEKGQpchd2gdU', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '可以的', '2023-02-21 16:51:07', '2023-02-21 16:51:07');
INSERT INTO `wf_im_record` VALUES ('-_Ur2-im7BemFe3ATRr4n', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '哎呀悠', '2023-02-21 16:37:32', '2023-02-21 16:37:32');
INSERT INTO `wf_im_record` VALUES ('-EYUCE3B4LeV0yOsRlCO4', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '妈卖批', '2023-02-21 17:00:32', '2023-02-21 17:00:32');
INSERT INTO `wf_im_record` VALUES ('0RR7qjlWyJ13esdSa9oL6', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '噢噢噢噢', '2023-02-21 20:08:08', '2023-02-21 20:08:08');
INSERT INTO `wf_im_record` VALUES ('0TK7et9xDSs-w36r0L-ki', '1c74da390df462ad541a3a4d010ecd24', 'a1c2c1150add8182cb2c4389cfdae0df', '🤮🤮', '2023-02-22 21:41:01', '2023-02-22 21:41:01');
INSERT INTO `wf_im_record` VALUES ('1EY18URmzRSGbaqHqP7rs', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '好的', '2023-02-21 01:26:45', '2023-02-21 01:26:45');
INSERT INTO `wf_im_record` VALUES ('2_fY7iM_NUGKmN6dE5q1N', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '啊顶顶顶', '2023-02-22 00:10:19', '2023-02-22 00:10:19');
INSERT INTO `wf_im_record` VALUES ('2fl5nSWCXOxU4FAzmfZhr', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '🤮🤩🤩', '2023-02-22 02:03:49', '2023-02-22 02:03:49');
INSERT INTO `wf_im_record` VALUES ('2tV0SbaQ7O9WTreRWCLyi', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '你好\n', '2023-02-21 14:48:38', '2023-02-21 14:48:38');
INSERT INTO `wf_im_record` VALUES ('3agMESSM5Y5zkzV-j1MUW', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '水水水水', '2023-02-21 17:13:25', '2023-02-21 17:13:25');
INSERT INTO `wf_im_record` VALUES ('3q6oq_gY_Okdz1iH7mDYj', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '噢噢噢噢', '2023-02-21 18:55:49', '2023-02-21 18:55:49');
INSERT INTO `wf_im_record` VALUES ('4gbWIKC1GjRxZCdrcX8Vn', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '搜索', '2023-02-22 01:28:07', '2023-02-22 01:28:07');
INSERT INTO `wf_im_record` VALUES ('6-0gtwoAfEFYu3ygjZzuT', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '曹', '2023-02-21 16:55:20', '2023-02-21 16:55:20');
INSERT INTO `wf_im_record` VALUES ('64RKovxLayNtlJXMkqAxM', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '饿呢', '2023-02-22 01:30:48', '2023-02-22 01:30:48');
INSERT INTO `wf_im_record` VALUES ('8bJbpjqpLZ1uHhFTnkTgu', '1c74da390df462ad541a3a4d010ecd24', 'a1c2c1150add8182cb2c4389cfdae0df', '😘😘', '2023-02-22 20:46:21', '2023-02-22 20:46:21');
INSERT INTO `wf_im_record` VALUES ('8ssJKkpvXrXtmlkJbHCw5', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '可以的', '2023-02-21 01:16:10', '2023-02-21 01:16:10');
INSERT INTO `wf_im_record` VALUES ('9OpDu3H24dsBLzf6zYset', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '🤙🤙', '2023-02-22 02:01:02', '2023-02-22 02:01:02');
INSERT INTO `wf_im_record` VALUES ('a08CY3BSiFDuA_0E7J-rJ', '1c74da390df462ad541a3a4d010ecd24', 'a1c2c1150add8182cb2c4389cfdae0df', '🤣🤣🤣', '2023-02-22 20:57:39', '2023-02-22 20:57:39');
INSERT INTO `wf_im_record` VALUES ('A3CLCLJjHCyqwUkmwCQ-c', '1c74da390df462ad541a3a4d010ecd24', '2ec80b30411dee0f3c4f98debf36da48', '🤮🤮', '2023-02-23 02:06:13', '2023-02-23 02:06:13');
INSERT INTO `wf_im_record` VALUES ('a7OjXNLG0ks4n5QZ9xk05', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '我不想长大', '2023-02-21 19:04:56', '2023-02-21 19:04:56');
INSERT INTO `wf_im_record` VALUES ('AASODCdcdH2hRyHz9cDoo', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '第几个100天', '2023-02-21 19:48:03', '2023-02-21 19:48:03');
INSERT INTO `wf_im_record` VALUES ('abmvsIa-pB73VZq9DxZQU', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '不好', '2023-02-22 01:31:52', '2023-02-22 01:31:52');
INSERT INTO `wf_im_record` VALUES ('AIMfVaPEkMtRfYuIiu7QE', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '你好啊', '2023-02-21 16:31:21', '2023-02-21 16:31:21');
INSERT INTO `wf_im_record` VALUES ('bdJCnqrBW0dEk2PB07F-O', '2ec80b30411dee0f3c4f98debf36da48', '1c74da390df462ad541a3a4d010ecd24', '😙😙', '2023-02-23 03:21:21', '2023-02-23 03:21:21');
INSERT INTO `wf_im_record` VALUES ('Bxn5OBCS0YX_RUnxQIcpO', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '🤡🤡', '2023-02-22 02:08:02', '2023-02-22 02:08:02');
INSERT INTO `wf_im_record` VALUES ('cJXli3rrdM7tfXPYVM9By', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '嗯嗯', '2023-02-22 01:29:20', '2023-02-22 01:29:20');
INSERT INTO `wf_im_record` VALUES ('cpr1Z-J7HSn6gJKDW7bNb', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '😹😹', '2023-02-22 02:01:37', '2023-02-22 02:01:37');
INSERT INTO `wf_im_record` VALUES ('cQgWCs2_9BRf6ueSZwnVz', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '11111', '2023-02-21 20:09:56', '2023-02-21 20:09:56');
INSERT INTO `wf_im_record` VALUES ('D7RGOizG2luSeNcYimw9n', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '🤮🤮', '2023-02-22 01:52:13', '2023-02-22 01:52:13');
INSERT INTO `wf_im_record` VALUES ('DlSrnEGFD_G6JPxh9DlPI', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '111🤮', '2023-02-21 17:14:34', '2023-02-21 17:14:34');
INSERT INTO `wf_im_record` VALUES ('dNND4m_w6DS4d0GevgQ0R', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '😹😹', '2023-02-22 02:04:10', '2023-02-22 02:04:10');
INSERT INTO `wf_im_record` VALUES ('draTeFQTeC627tXuLVNlP', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '我不是很好', '2023-02-21 14:59:31', '2023-02-21 14:59:31');
INSERT INTO `wf_im_record` VALUES ('DwA0WuDrlEFmwjrdAJCQL', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '好的', '2023-02-21 01:27:05', '2023-02-21 01:27:05');
INSERT INTO `wf_im_record` VALUES ('dYX3UjzHp8k8IIFryQFJM', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '你好小旅行者', '2023-02-21 21:05:45', '2023-02-21 21:05:45');
INSERT INTO `wf_im_record` VALUES ('EXai1p8IbQwnGlC5VaQme', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '🙏🙏', '2023-02-22 02:02:06', '2023-02-22 02:02:06');
INSERT INTO `wf_im_record` VALUES ('Ey5otfFaPxr0JXIg4n1Ha', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '🤮🤮', '2023-02-22 01:57:41', '2023-02-22 01:57:41');
INSERT INTO `wf_im_record` VALUES ('fKa9jbKJLktbCya38LTAL', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '啊对对对', '2023-02-22 00:10:09', '2023-02-22 00:10:09');
INSERT INTO `wf_im_record` VALUES ('fsqBnQIZwL8CWXMsYexTw', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '来吧宝贝', '2023-02-21 16:55:09', '2023-02-21 16:55:09');
INSERT INTO `wf_im_record` VALUES ('fzEpbji6knGW1oNEXiOmw', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '是啊', '2023-02-21 18:54:48', '2023-02-21 18:54:48');
INSERT INTO `wf_im_record` VALUES ('Fzyj1iO52HEy7kBViz3W4', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '111111111', '2023-02-21 17:30:27', '2023-02-21 17:30:27');
INSERT INTO `wf_im_record` VALUES ('g0A3esNGotoYQKKmUC4lR', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '😨😨', '2023-02-22 02:05:09', '2023-02-22 02:05:09');
INSERT INTO `wf_im_record` VALUES ('gf-ebU5APnUmJLtaaoNFi', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '嗡嗡嗡', '2023-02-21 20:59:18', '2023-02-21 20:59:18');
INSERT INTO `wf_im_record` VALUES ('gFyGshTeWSgIL5UjdGvxa', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '好的', '2023-02-22 01:31:35', '2023-02-22 01:31:35');
INSERT INTO `wf_im_record` VALUES ('gHD7e3yY_uAQwUo_Aolhv', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '搜索', '2023-02-21 19:02:08', '2023-02-21 19:02:08');
INSERT INTO `wf_im_record` VALUES ('gNmTe3XS3wK2J_e2e2duW', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '杀杀杀', '2023-02-22 01:24:57', '2023-02-22 01:24:57');
INSERT INTO `wf_im_record` VALUES ('h-6brC7RTja-hAvP8FSLF', '1c74da390df462ad541a3a4d010ecd24', 'a1c2c1150add8182cb2c4389cfdae0df', '😀😀', '2023-02-22 20:56:46', '2023-02-22 20:56:46');
INSERT INTO `wf_im_record` VALUES ('h1KdPysAJFblIi8WV0uub', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '哎呦', '2023-02-21 16:58:22', '2023-02-21 16:58:22');
INSERT INTO `wf_im_record` VALUES ('hzLfPgoyn1cOdUu6U8Fg5', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '你好', '2023-02-21 14:57:36', '2023-02-21 14:57:36');
INSERT INTO `wf_im_record` VALUES ('I6ZZ6XKKeOVTVI4SZL1Fg', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '发不出去这个消息', '2023-02-21 01:50:30', '2023-02-21 01:50:30');
INSERT INTO `wf_im_record` VALUES ('IanIbO2FpRSec2V7Mq1dd', '2ec80b30411dee0f3c4f98debf36da48', '1c74da390df462ad541a3a4d010ecd24', '😅😅', '2023-02-23 02:12:10', '2023-02-23 02:12:10');
INSERT INTO `wf_im_record` VALUES ('IFPXeRnw194lIMg4-V_tA', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '😝😝', '2023-02-22 01:51:28', '2023-02-22 01:51:28');
INSERT INTO `wf_im_record` VALUES ('IJNefaIzQOP-N4nhrtFD_', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '嘿嘿', '2023-02-21 17:12:41', '2023-02-21 17:12:41');
INSERT INTO `wf_im_record` VALUES ('ImVPp0Bzl1jctarQxT7K6', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '嗯呢', '2023-02-22 01:28:59', '2023-02-22 01:28:59');
INSERT INTO `wf_im_record` VALUES ('IOT1a8SxxWpAYhbLneJc4', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '好的', '2023-02-21 01:26:43', '2023-02-21 01:26:43');
INSERT INTO `wf_im_record` VALUES ('IvdCx_HgRXUECm1NigJz8', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '杀杀杀', '2023-02-22 01:25:04', '2023-02-22 01:25:04');
INSERT INTO `wf_im_record` VALUES ('JW-LVJXTiaDyV8ZXqaxEe', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '🤣🤣', '2023-02-22 01:56:36', '2023-02-22 01:56:36');
INSERT INTO `wf_im_record` VALUES ('Jxhuj5ufW5voQ3fKVlbac', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '烦啊', '2023-02-21 17:03:05', '2023-02-21 17:03:05');
INSERT INTO `wf_im_record` VALUES ('JyV2Fwf0Un1WzjgYRJPIO', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', 'hello啊', '2023-02-21 00:09:53', '2023-02-21 00:09:53');
INSERT INTO `wf_im_record` VALUES ('kFeuIHlcBfNY6fVIFHCq2', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '我日', '2023-02-21 16:53:10', '2023-02-21 16:53:10');
INSERT INTO `wf_im_record` VALUES ('KQt_Aw9C_Jipf2TCFDtsu', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '😙😙', '2023-02-22 02:05:46', '2023-02-22 02:05:46');
INSERT INTO `wf_im_record` VALUES ('kZCebQz5tmtjrUyQkEmx_', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '我不雷猴', '2023-02-22 00:09:48', '2023-02-22 00:09:48');
INSERT INTO `wf_im_record` VALUES ('lLwOlYnlj1VuCKZEes9qQ', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '你也雷猴', '2023-02-22 00:09:07', '2023-02-22 00:09:07');
INSERT INTO `wf_im_record` VALUES ('llx86KSw0A1s4TMCkxWGo', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '😘😘', '2023-02-22 02:04:26', '2023-02-22 02:04:26');
INSERT INTO `wf_im_record` VALUES ('lzGACcwlYmiChKXex-pG4', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '111111111111', '2023-02-21 17:30:13', '2023-02-21 17:30:13');
INSERT INTO `wf_im_record` VALUES ('M0_sledYeWn0v9-nM6opP', '1c74da390df462ad541a3a4d010ecd24', 'a1c2c1150add8182cb2c4389cfdae0df', '🤩🤩', '2023-02-22 20:49:57', '2023-02-22 20:49:57');
INSERT INTO `wf_im_record` VALUES ('mCx6SV-IVheAGGnTSD3Up', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '😱😱', '2023-02-22 02:06:10', '2023-02-22 02:06:10');
INSERT INTO `wf_im_record` VALUES ('MgREzioyb1qEHbDNXWLvY', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', 'hello我', '2023-02-22 01:03:47', '2023-02-22 01:03:47');
INSERT INTO `wf_im_record` VALUES ('MolY90IaeMTXAvuVnJMVw', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '嗯', '2023-02-21 01:40:32', '2023-02-21 01:40:32');
INSERT INTO `wf_im_record` VALUES ('N3Cviglb86-qOS304QUdX', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '😨😨', '2023-02-22 01:53:34', '2023-02-22 01:53:34');
INSERT INTO `wf_im_record` VALUES ('n4cmHFaA4TfuqE0WvYhMd', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '呃呃呃', '2023-02-22 01:32:27', '2023-02-22 01:32:27');
INSERT INTO `wf_im_record` VALUES ('n6ep-oJgRdItpYo3wFBKU', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '😰😰', '2023-02-22 02:07:42', '2023-02-22 02:07:42');
INSERT INTO `wf_im_record` VALUES ('NQkw3wkon8MP_xsFL1-pO', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '😭😭', '2023-02-22 02:00:34', '2023-02-22 02:00:34');
INSERT INTO `wf_im_record` VALUES ('NWtfor1qmb_5geG0rdTsv', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '乌鱼子', '2023-02-21 20:11:41', '2023-02-21 20:11:41');
INSERT INTO `wf_im_record` VALUES ('oMkFYanI1kiKmYdy05uHg', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '你好旅行者', '2023-02-21 21:04:25', '2023-02-21 21:04:25');
INSERT INTO `wf_im_record` VALUES ('OPFyvZ3NTJqe6r4vVpciH', '1c74da390df462ad541a3a4d010ecd24', '2ec80b30411dee0f3c4f98debf36da48', '😙😙', '2023-02-23 02:07:32', '2023-02-23 02:07:32');
INSERT INTO `wf_im_record` VALUES ('OqnRyHZYGt3uYfPTfUSEq', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '杀杀杀', '2023-02-22 01:28:45', '2023-02-22 01:28:45');
INSERT INTO `wf_im_record` VALUES ('ous6ZdGDHHyJFmDXRlWcr', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', 'hello', '2023-02-21 19:46:07', '2023-02-21 19:46:07');
INSERT INTO `wf_im_record` VALUES ('P9CoecTQMLRxd6QSQ3mZk', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '🤝🤝', '2023-02-22 02:04:39', '2023-02-22 02:04:39');
INSERT INTO `wf_im_record` VALUES ('PYclGjS-GAkliqCkjPV0X', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '妈卖批', '2023-02-21 17:01:03', '2023-02-21 17:01:03');
INSERT INTO `wf_im_record` VALUES ('q-TVCicYqWvrDsNcTNW3m', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '你好', '2023-02-21 01:43:37', '2023-02-21 01:43:37');
INSERT INTO `wf_im_record` VALUES ('q7-DbYpM3Lc6E7xfuqH8z', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '雷猴', '2023-02-22 00:07:42', '2023-02-22 00:07:42');
INSERT INTO `wf_im_record` VALUES ('qN1iSeUFRs4Qb91dhNn6R', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '扣你吉瓦', '2023-02-21 01:33:52', '2023-02-21 01:33:52');
INSERT INTO `wf_im_record` VALUES ('qPOGloMwoQJvvOSCg_3PW', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', 'hello希望bug消失😱😱😱', '2023-02-21 01:52:43', '2023-02-21 01:52:43');
INSERT INTO `wf_im_record` VALUES ('rMSQVg5IioGjY3InY8hIA', '1c74da390df462ad541a3a4d010ecd24', 'a1c2c1150add8182cb2c4389cfdae0df', '😰', '2023-02-23 01:58:34', '2023-02-23 01:58:34');
INSERT INTO `wf_im_record` VALUES ('RUXsDr6MhKgd9jDKsoU5r', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '雷猴啊', '2023-02-22 01:03:57', '2023-02-22 01:03:57');
INSERT INTO `wf_im_record` VALUES ('SDQ7dGqTg2z4u-qqbFFYo', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '哦哦哦', '2023-02-21 19:54:09', '2023-02-21 19:54:09');
INSERT INTO `wf_im_record` VALUES ('sPHVvP1x4E8L8KeMcLpfS', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '11111111', '2023-02-21 20:10:30', '2023-02-21 20:10:30');
INSERT INTO `wf_im_record` VALUES ('sSjfi5ctFQND6Y0OqfLFb', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '呃呃呃呃😁', '2023-02-22 01:32:38', '2023-02-22 01:32:38');
INSERT INTO `wf_im_record` VALUES ('sxqyzyCLDy23LvCz2Fel0', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '杀杀杀', '2023-02-22 01:25:12', '2023-02-22 01:25:12');
INSERT INTO `wf_im_record` VALUES ('th9xdtx5LGmLXIGj328KU', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '嘿嘿', '2023-02-21 17:06:17', '2023-02-21 17:06:17');
INSERT INTO `wf_im_record` VALUES ('TJiGtpybBmozm7jrgLAVL', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '好像你', '2023-02-22 01:31:14', '2023-02-22 01:31:14');
INSERT INTO `wf_im_record` VALUES ('tTFHaS3GLjyvdA7hskhTb', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '😙😙', '2023-02-22 02:03:44', '2023-02-22 02:03:44');
INSERT INTO `wf_im_record` VALUES ('Tw16qiR0Eru-kpnBrtfyD', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '嗯', '2023-02-21 01:07:52', '2023-02-21 01:07:52');
INSERT INTO `wf_im_record` VALUES ('Uc74dqItCHRyuF83mG-1u', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '你好', '2023-02-21 20:06:28', '2023-02-21 20:06:28');
INSERT INTO `wf_im_record` VALUES ('UeFOXHd-tomcp57bzWQWO', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '可以了欸😀', '2023-02-21 01:50:56', '2023-02-21 01:50:56');
INSERT INTO `wf_im_record` VALUES ('Un22gIqG6i8FiCQt5xOXP', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '曹', '2023-02-21 16:52:54', '2023-02-21 16:52:54');
INSERT INTO `wf_im_record` VALUES ('uXogLGJ4kkbyhF_N9z2_L', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '嗯', '2023-02-22 01:28:50', '2023-02-22 01:28:50');
INSERT INTO `wf_im_record` VALUES ('V7MkGTIAzVZKle5zm3YKX', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '顶顶顶', '2023-02-22 01:01:36', '2023-02-22 01:01:36');
INSERT INTO `wf_im_record` VALUES ('VKx_4vZkMpbb51_mkNlPF', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '是', '2023-02-21 01:40:14', '2023-02-21 01:40:14');
INSERT INTO `wf_im_record` VALUES ('vXK0YEyzQnOfp6ZALlJN_', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '呃呃呃呃', '2023-02-22 01:32:45', '2023-02-22 01:32:45');
INSERT INTO `wf_im_record` VALUES ('WAnCuIQaSMyfCxegCufdM', '1c74da390df462ad541a3a4d010ecd24', 'a1c2c1150add8182cb2c4389cfdae0df', '🤩🤩🤣', '2023-02-22 20:52:23', '2023-02-22 20:52:23');
INSERT INTO `wf_im_record` VALUES ('WH3xZXKn88MFgO2MGUnsA', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '我不好', '2023-02-21 16:32:28', '2023-02-21 16:32:28');
INSERT INTO `wf_im_record` VALUES ('XkHmBNjkl2h4oOR1w4i8N', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', '不饿', '2023-02-22 01:30:59', '2023-02-22 01:30:59');
INSERT INTO `wf_im_record` VALUES ('Y_AxbP2ZeiZCOHXLnScdz', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '雷猴', '2023-02-21 16:35:28', '2023-02-21 16:35:28');
INSERT INTO `wf_im_record` VALUES ('y2HAQj-n8gWAGLPMzacwA', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '😟😟', '2023-02-22 01:58:14', '2023-02-22 01:58:14');
INSERT INTO `wf_im_record` VALUES ('y8TC8TNg47aixf3v9ahRd', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '🤡🤡', '2023-02-22 02:04:56', '2023-02-22 02:04:56');
INSERT INTO `wf_im_record` VALUES ('yj19TGc-B0YVQSoknlc3u', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '哦哦', '2023-02-21 19:42:29', '2023-02-21 19:42:29');
INSERT INTO `wf_im_record` VALUES ('zdzFMv5n39tSy7JKBRpqM', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', '你好', '2023-02-21 16:30:35', '2023-02-21 16:30:35');

-- ----------------------------
-- Table structure for wf_im_unread_record
-- ----------------------------
DROP TABLE IF EXISTS `wf_im_unread_record`;
CREATE TABLE `wf_im_unread_record`  (
  `uuid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `user_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户ID',
  `to_user_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '私聊者ID',
  `count` int NULL DEFAULT NULL COMMENT '未读消息数量',
  `create_time` datetime NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  PRIMARY KEY (`uuid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of wf_im_unread_record
-- ----------------------------
INSERT INTO `wf_im_unread_record` VALUES ('0f5affe508635c76ae8d5b9d199c9458', '2ec80b30411dee0f3c4f98debf36da48', '1c74da390df462ad541a3a4d010ecd24', 2, '2023-02-23 02:12:10', '2023-02-23 02:12:10');
INSERT INTO `wf_im_unread_record` VALUES ('3d8bfb38f53d8a7c20b9bdab76c5dda2', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', 0, '2023-02-21 01:26:43', '2023-02-21 01:26:43');
INSERT INTO `wf_im_unread_record` VALUES ('bb6d2457c22fbd5950a7b235eadca1d6', '2ec80b30411dee0f3c4f98debf36da48', 'a1c2c1150add8182cb2c4389cfdae0df', 0, '2023-02-21 00:09:53', '2023-02-21 00:09:53');
INSERT INTO `wf_im_unread_record` VALUES ('ce48e6481d1a7e9770b2498f74ff7543', '1c74da390df462ad541a3a4d010ecd24', '2ec80b30411dee0f3c4f98debf36da48', 0, '2023-02-23 02:06:13', '2023-02-23 02:06:13');
INSERT INTO `wf_im_unread_record` VALUES ('faac3f41da8437fd4a264f34c41539ae', '1c74da390df462ad541a3a4d010ecd24', 'a1c2c1150add8182cb2c4389cfdae0df', 0, '2023-02-22 20:46:21', '2023-02-22 20:46:21');

-- ----------------------------
-- Table structure for wf_label
-- ----------------------------
DROP TABLE IF EXISTS `wf_label`;
CREATE TABLE `wf_label`  (
  `uuid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '主键',
  `label_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '标签名',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`uuid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of wf_label
-- ----------------------------
INSERT INTO `wf_label` VALUES ('1', 'Java', '2023-01-14 23:05:43', '2023-01-14 23:05:45');
INSERT INTO `wf_label` VALUES ('2', 'React', '2023-01-14 23:06:08', '2023-01-14 23:06:13');
INSERT INTO `wf_label` VALUES ('3', 'Vue', '2023-01-14 23:06:26', '2023-01-14 23:06:30');
INSERT INTO `wf_label` VALUES ('4', 'Python', '2023-01-14 23:06:41', '2023-01-14 23:06:44');

-- ----------------------------
-- Table structure for wf_notification_unread
-- ----------------------------
DROP TABLE IF EXISTS `wf_notification_unread`;
CREATE TABLE `wf_notification_unread`  (
  `uuid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `user_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户ID',
  `like_count` int NULL DEFAULT NULL COMMENT '点赞未读消息数',
  `comment_count` int NULL DEFAULT NULL COMMENT '评论未读消息数',
  `focus_count` int NULL DEFAULT NULL COMMENT '关注未读消息数',
  `create_time` datetime NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  PRIMARY KEY (`uuid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of wf_notification_unread
-- ----------------------------
INSERT INTO `wf_notification_unread` VALUES ('1', '1c74da390df462ad541a3a4d010ecd24', 0, 0, 0, '2023-02-24 01:26:39', '2023-02-24 01:26:42');
INSERT INTO `wf_notification_unread` VALUES ('2', '2ec80b30411dee0f3c4f98debf36da48', 0, 0, 0, '2023-02-24 01:26:55', '2023-02-24 01:39:53');
INSERT INTO `wf_notification_unread` VALUES ('3', 'a1c2c1150add8182cb2c4389cfdae0df', 0, 0, 0, '2023-02-24 01:27:11', '2023-02-25 23:58:33');

-- ----------------------------
-- Table structure for wf_sort
-- ----------------------------
DROP TABLE IF EXISTS `wf_sort`;
CREATE TABLE `wf_sort`  (
  `uuid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '主键',
  `sort_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '分类名',
  `route_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '路由名',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`uuid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of wf_sort
-- ----------------------------
INSERT INTO `wf_sort` VALUES ('1', '前端', 'font', '2023-01-14 22:07:16', '2023-01-14 22:07:18');
INSERT INTO `wf_sort` VALUES ('2', '后端', 'back', '2023-01-14 22:07:21', '2023-01-14 22:07:23');
INSERT INTO `wf_sort` VALUES ('3', '人工智能', 'ai', '2023-01-14 22:07:26', '2023-01-14 22:07:29');

-- ----------------------------
-- Table structure for wf_store_list
-- ----------------------------
DROP TABLE IF EXISTS `wf_store_list`;
CREATE TABLE `wf_store_list`  (
  `uuid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT 'uuid主键',
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '收藏夹名称',
  `summary` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '收藏夹文章描述',
  `state` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '收藏夹状态(1:公开,2:隐私)',
  `user_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户ID',
  `article_num` int NULL DEFAULT NULL COMMENT '文章数',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`uuid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of wf_store_list
-- ----------------------------
INSERT INTO `wf_store_list` VALUES ('11a41cfe1ee469caab9b4b20ce525d57', '客户端', NULL, '2', '2ec80b30411dee0f3c4f98debf36da48', 0, '2023-01-31 18:15:40', '2023-01-31 18:15:40');
INSERT INTO `wf_store_list` VALUES ('1620119971030237186', '前端', '无', '1', '2ec80b30411dee0f3c4f98debf36da48', 0, '2023-01-31 02:01:16', '2023-01-31 02:01:16');
INSERT INTO `wf_store_list` VALUES ('1620121202624761857', '后端', '无', '1', '2ec80b30411dee0f3c4f98debf36da48', 0, '2023-01-31 02:06:10', '2023-01-31 02:06:10');
INSERT INTO `wf_store_list` VALUES ('1620121316537864194', '人工智能', '', '1', '2ec80b30411dee0f3c4f98debf36da48', 0, '2023-01-31 02:06:37', '2023-01-31 02:06:37');
INSERT INTO `wf_store_list` VALUES ('fa0dd3f21030253f7862c0e6edeb79ae', 'AI', NULL, '1', '2ec80b30411dee0f3c4f98debf36da48', 0, '2023-01-31 17:53:52', '2023-01-31 17:53:52');

-- ----------------------------
-- Table structure for wf_user
-- ----------------------------
DROP TABLE IF EXISTS `wf_user`;
CREATE TABLE `wf_user`  (
  `uuid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '主键',
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户账号',
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '密码',
  `email_address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '邮箱',
  `sex` tinyint NULL DEFAULT NULL COMMENT '键值(1：男，2：女)',
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '头像链接',
  `company_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '公司名称',
  `position` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '职位',
  `person_profile` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '个人简介',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`uuid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of wf_user
-- ----------------------------
INSERT INTO `wf_user` VALUES ('1c74da390df462ad541a3a4d010ecd24', 'captain', '$2a$10$AuQa6Tx/T0Br6ESPmY9dK.8HnB2HxCHHRkpg3y/vQeOf9/tRx/S16', '1027641037@qq.com', NULL, 'https://p3-passport.byteimg.com/img/mosaic-legacy/3795/3033762272~180x180.awebp', NULL, NULL, NULL, '2023-01-05 16:04:07', NULL);
INSERT INTO `wf_user` VALUES ('2ec80b30411dee0f3c4f98debf36da48', 'heiheide', '$2a$10$qjzdeKiylotWjMl4WkMbluDmnamd8X7czdhIAokg1dmKrxJE5M7t6', '1027641036@qq.com', NULL, 'https://p3-passport.byteimg.com/img/mosaic-legacy/3795/3033762272~180x180.awebp', NULL, NULL, NULL, '2023-01-30 01:35:52', '2023-01-30 01:35:52');
INSERT INTO `wf_user` VALUES ('a1c2c1150add8182cb2c4389cfdae0df', 'captiansss', '$2a$10$o.G1sgqqkVfLEsDn5iYFZ.zRElCp4x0nYZl8b3fb.mBBahkv6UAHK', '1027641035@qq.com', NULL, 'https://p3-passport.byteimg.com/img/mosaic-legacy/3795/3033762272~180x180.awebp', NULL, NULL, NULL, '2023-01-11 21:58:04', NULL);

-- ----------------------------
-- Table structure for wf_user_subscribe
-- ----------------------------
DROP TABLE IF EXISTS `wf_user_subscribe`;
CREATE TABLE `wf_user_subscribe`  (
  `uuid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `be_subscribed_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '被关注者ID',
  `subscribed_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '关注者ID',
  `is_del` tinyint NULL DEFAULT NULL COMMENT '记录是否存在：0关注，1取关）',
  `create_time` datetime NULL DEFAULT NULL,
  `update_time` datetime NULL DEFAULT NULL,
  PRIMARY KEY (`uuid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of wf_user_subscribe
-- ----------------------------
INSERT INTO `wf_user_subscribe` VALUES ('5bc4b06b28761ae03a9e732ce6f5a8ba', 'a1c2c1150add8182cb2c4389cfdae0df', '2ec80b30411dee0f3c4f98debf36da48', 1, '2023-02-03 03:28:55', '2023-02-03 03:34:02');

SET FOREIGN_KEY_CHECKS = 1;
